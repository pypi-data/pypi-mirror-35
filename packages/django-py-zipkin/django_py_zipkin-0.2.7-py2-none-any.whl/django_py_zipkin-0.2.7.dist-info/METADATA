Metadata-Version: 2.0
Name: django-py-zipkin
Version: 0.2.7
Summary: py2 & py3 compatible zipkin for Django
Home-page: https://github.com/praekeltfoundation/django-py-zipkin
Author: Simon de Haan
Author-email: simon@praekelt.org
License: UNKNOWN
Description-Content-Type: UNKNOWN
Keywords: zipkin
Platform: UNKNOWN
Classifier: Intended Audience :: Developers
Classifier: Natural Language :: English
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3.6
Requires-Dist: Django
Requires-Dist: celery
Requires-Dist: requests
Requires-Dist: py-zipkin (==0.8.3)
Provides-Extra: dev
Requires-Dist: pytest (<4.0,>=3.6); extra == 'dev'
Requires-Dist: pytest-xdist; extra == 'dev'
Requires-Dist: pytest-django (<4.0,>=3.3.3); extra == 'dev'
Requires-Dist: mock; extra == 'dev'
Requires-Dist: responses; extra == 'dev'
Requires-Dist: flake8; extra == 'dev'

Django-py-zipkin
================

Django middleware and tracing utilities for submitting traces to Zipkin.
py2 / py3 compatible.

Usage
~~~~~

Set the settings, if not set it'll use defaults:

*ZIPKIN_SERVICE_NAME*: ``unknown``
    The name to use when identifying the service being traced.

*ZIPKIN_TRANSPORT_HANDLER*: ``django_py_zipkin.transport.zipkin_transport``
    Transport to use to submit traces to Zipkin. The default one submits
    in the background via Celery.

*ZIPKIN_ADD_LOGGING_ANNOTATION*: ``True``
    Whether to add a 'logging_end' annotation when py_zipkin
    finishes logging spans

*ZIPKIN_TRACING_ENABLED*: ``False``
    Whether or not to enable tracing, requires explicit enabling.

*ZIPKIN_TRACING_SAMPLING*: ``1.00``
    The sampling threshold

*ZIPKIN_BLACKLISTED_PATHS*: ``[]``
    List of regular expressions to ignore from tracing.

Add the middleware

::

    MIDDLEWARE = [
        ...
        'django_py_zipkin.middleware.ZipkinMiddleware',
        ...
    ]

Or instrument your code with the context manager::

    with trace('span-name', request.zipkin_tracer) as context
        traced_value = do_something_that_takes_time()
        context.update({
            'some.key': traced_value,
        })


