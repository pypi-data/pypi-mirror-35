
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>aglyph.component &#8212; Aglyph 3.0.0.post1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for aglyph.component</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: UTF-8 -*-</span>

<span class="c1"># Copyright (c) 2006, 2011, 2013-2018 Matthew Zipay.</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person</span>
<span class="c1"># obtaining a copy of this software and associated documentation</span>
<span class="c1"># files (the &quot;Software&quot;), to deal in the Software without</span>
<span class="c1"># restriction, including without limitation the rights to use,</span>
<span class="c1"># copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the</span>
<span class="c1"># Software is furnished to do so, subject to the following</span>
<span class="c1"># conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be</span>
<span class="c1"># included in all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="c1"># EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES</span>
<span class="c1"># OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="c1"># NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT</span>
<span class="c1"># HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,</span>
<span class="c1"># WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="c1"># FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<span class="c1"># OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;The classes in this module are used to define components and their</span>
<span class="sd">dependencies within an Aglyph context (:class:`aglyph.context.Context`).</span>

<span class="sd">.. rubric:: Components and Templates</span>

<span class="sd">:class:`aglyph.component.Component` tells an</span>
<span class="sd">:class:`aglyph.assembler.Assembler` how to create objects of a</span>
<span class="sd">particular type. The component defines the initialization and/or</span>
<span class="sd">attribute dependencies for objects of that type, as well as the assembly</span>
<span class="sd">strategy and any lifecycle methods that should be called.</span>

<span class="sd">:class:`aglyph.component.Template` is used to describe dependencies</span>
<span class="sd">(initialization and/or attribute) and lifecylce methods that are shared</span>
<span class="sd">by multiple components. Templates are similar to abstract classes; they</span>
<span class="sd">cannot be assembled, but are instead used as &quot;parents&quot; of other</span>
<span class="sd">components (or templates) to achieve a sort of &quot;configuration</span>
<span class="sd">inheritance.&quot;</span>

<span class="sd">.. note::</span>
<span class="sd">   Both ``Component`` and ``Template`` may serve as the parent of any</span>
<span class="sd">   other component or template; but only components may be assembled.</span>

<span class="sd">.. rubric:: References and Evaluators</span>

<span class="sd">A :class:`aglyph.component.Reference` may be used as the value of any</span>
<span class="sd">initialization argument (positional or keyword) or attribute in a</span>
<span class="sd">component or template. Its value must be the unique ID of a</span>
<span class="sd">**component** in the same context. At assembly time, the assembler will</span>
<span class="sd">resolve the reference into an object of the component to which it</span>
<span class="sd">refers.</span>

<span class="sd">An :class:`aglyph.component.Evaluator` is similar to a</span>
<span class="sd">:func:`functools.partial` object. It stores a callable factory (function</span>
<span class="sd">or class) and related initialization arguments, and can be called</span>
<span class="sd">repeatedly to produce new objects. (Unlike a :func:`functools.partial`</span>
<span class="sd">object, though, an ``Evaluator`` will resolve any initialization</span>
<span class="sd">argument that is a :class:`aglyph.component.Reference`,</span>
<span class="sd">:func:`functools.partial`, or ``Evaluator`` **before** calling the</span>
<span class="sd">factory.)</span>

<span class="sd">.. rubric:: Strategies and Lifecycle methods</span>

<span class="sd">:data:`aglyph.component.Strategy` defines the assembly strategies</span>
<span class="sd">supported by Aglyph (*&quot;prototype&quot;*, *&quot;singleton&quot;*, *&quot;borg&quot;*,</span>
<span class="sd">*&quot;weakref&quot;* and *&quot;_imported&quot;*).</span>

<span class="sd">:data:`LifecycleState` defines assmebly states for components at</span>
<span class="sd">which Aglyph supports calling named methods on the objects of those</span>
<span class="sd">components. (Such methods may be used to perform specialized</span>
<span class="sd">initialization or disposal, for example.)</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Matthew Zipay &lt;mattz@ninthtest.info&gt;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">isclass</span><span class="p">,</span> <span class="n">ismodule</span><span class="p">,</span> <span class="n">isroutine</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">autologging</span> <span class="k">import</span> <span class="n">logged</span><span class="p">,</span> <span class="n">traced</span>

<span class="kn">from</span> <span class="nn">aglyph</span> <span class="k">import</span> <span class="n">AglyphError</span><span class="p">,</span> <span class="n">_identify</span><span class="p">,</span> <span class="n">__version__</span>
<span class="kn">from</span> <span class="nn">aglyph._compat</span> <span class="k">import</span> <span class="n">is_string</span><span class="p">,</span> <span class="n">name_of</span><span class="p">,</span> <span class="n">TextType</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Strategy&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LifecycleState&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Reference&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Evaluator&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Template&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Component&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">Strategy</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
    <span class="s2">&quot;Strategy&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;PROTOTYPE&quot;</span><span class="p">,</span> <span class="s2">&quot;SINGLETON&quot;</span><span class="p">,</span> <span class="s2">&quot;BORG&quot;</span><span class="p">,</span> <span class="s2">&quot;WEAKREF&quot;</span><span class="p">])(</span>
        <span class="s2">&quot;prototype&quot;</span><span class="p">,</span> <span class="s2">&quot;singleton&quot;</span><span class="p">,</span> <span class="s2">&quot;borg&quot;</span><span class="p">,</span> <span class="s2">&quot;weakref&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Define the component assembly strategies implemented by Aglyph.</span>

<span class="sd">.. rubric:: &quot;prototype&quot;</span>

<span class="sd">A new object is always created, initialized, wired, and returned.</span>

<span class="sd">.. note::</span>
<span class="sd">   &quot;prototype&quot; is the default assembly strategy for Aglyph components</span>
<span class="sd">   that do not specify a member name.</span>

<span class="sd">.. rubric:: &quot;singleton&quot;</span>

<span class="sd">The cached object is returned if it exists. Otherwise, the object is</span>
<span class="sd">created, initialized, wired, cached, and returned.</span>

<span class="sd">Singleton component objects are cached by :attr:`Component.unique_id`.</span>

<span class="sd">.. rubric:: &quot;borg&quot;</span>

<span class="sd">A new instance is always created. The shared-state is assigned to the</span>
<span class="sd">new instance&#39;s ``__dict__`` if it exists. Otherwise, the new instance is</span>
<span class="sd">initialized and wired, its instance ``__dict__`` is cached, and then the</span>
<span class="sd">instance is returned.</span>

<span class="sd">Borg component instance shared-states are cached by</span>
<span class="sd">:attr:`Component.unique_id`.</span>

<span class="sd">.. warning::</span>
<span class="sd">   * The borg assembly strategy is **only** supported for</span>
<span class="sd">     components that are non-builtin classes.</span>
<span class="sd">   * The borg assembly strategy is **not** supported for</span>
<span class="sd">     classes that define or inherit a ``__slots__`` member.</span>

<span class="sd">.. rubric:: &quot;weakref&quot;</span>

<span class="sd">In the simplest terms, this is a &quot;prototype&quot; that can exhibit</span>
<span class="sd">&quot;singleton&quot; behavior: as long as there is at least one &quot;live&quot; reference</span>
<span class="sd">to the assembled object in the application runtime, then requests to</span>
<span class="sd">assemble this component will return the same (cached) object.</span>

<span class="sd">When the only reference to the assembled object that remains is the</span>
<span class="sd">cached weak reference, the Python garbage collector is free to destroy</span>
<span class="sd">the object, at which point it is automatically removed from the Aglyph</span>
<span class="sd">cache.</span>

<span class="sd">Subsequent requests to assemble the same component will cause a new</span>
<span class="sd">object to be created, initialized, wired, cached (as a weak reference),</span>
<span class="sd">and returned.</span>

<span class="sd">.. note::</span>
<span class="sd">   Please refer to the :mod:`weakref` module for a detailed explanation</span>
<span class="sd">   of weak reference behavior.</span>

<span class="sd">.. rubric:: &quot;_imported&quot;</span>

<span class="sd">.. versionadded:: 3.0.0</span>

<span class="sd">.. note::</span>
<span class="sd">   The &quot;_imported&quot; strategy is only valid (and is the only allowed</span>
<span class="sd">   value) when *member_name* is specified for a component.</span>

<span class="sd">   Since this strategy is implicitly assigned and is intended for</span>
<span class="sd">   internal use by Aglyph itself, it is not exposed on the</span>
<span class="sd">   ``Strategy`` named tuple.</span>

<span class="sd">An already-created (loaded) object is obtained from an imported module</span>
<span class="sd">or class (as opposed to creating the object directly).</span>
<span class="sd">Such components will always resolve (i.e. be assembled) to the same</span>
<span class="sd">objects; but those objects are not cached by Aglyph as they will</span>
<span class="sd">exhibit &quot;natural&quot; singleton behavior so long as the containing module</span>
<span class="sd">is referenced in :attr:`sys.modules`.</span>

<span class="sd">It is not necessary to explicitly set the strategy to &quot;_imported&quot; when</span>
<span class="sd">using *member_name* - Aglyph will default to &quot;_imported&quot; when it sees</span>
<span class="sd">a non-empty *member_name* defined.</span>

<span class="sd">.. warning::</span>
<span class="sd">   Explicitly setting strategy=&quot;_imported&quot; **without** specifying</span>
<span class="sd">   *member_name* will raise :exc:`AglyphError`.</span>

<span class="sd">   Specifying *member_name* with any explicit strategy other than</span>
<span class="sd">   &quot;_imported&quot; will ignore the explicit strategy, change it to</span>
<span class="sd">   &quot;_imported&quot; internally, and issue a :class:`UserWarning` to that</span>
<span class="sd">   effect.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">LifecycleState</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
    <span class="s2">&quot;LifecycleState&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;AFTER_INJECT&quot;</span><span class="p">,</span> <span class="s2">&quot;BEFORE_CLEAR&quot;</span><span class="p">])(</span>
        <span class="s2">&quot;after_inject&quot;</span><span class="p">,</span> <span class="s2">&quot;before_clear&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Define the lifecycle states for which Aglyph will call object methods</span>
<span class="sd">on your behalf.</span>

<span class="sd">.. _lifecycle-methods:</span>

<span class="sd">.. rubric:: Lifecycle methods</span>

<span class="sd">Lifecycle methods are called with **no arguments** (positional or</span>
<span class="sd">keyword).</span>

<span class="sd">If a called lifecycle method raises an exception, the exception is</span>
<span class="sd">caught, logged at :attr:`logging.ERROR` level (including a traceback) to</span>
<span class="sd">the &quot;aglyph.assembler.Assembler&quot; channel, and a :class:`RuntimeWarning`</span>
<span class="sd">is issued.</span>

<span class="sd">A method may be registered for a lifecycle state by specifying the</span>
<span class="sd">method name at the context (least specific), template, and/or component</span>
<span class="sd">(most specific) level.</span>

<span class="sd">.. note::</span>
<span class="sd">   Aglyph only calls **one** method on an object for any lifecycle</span>
<span class="sd">   state. Refer to **The lifecycle method lookup process** (below) for</span>
<span class="sd">   details.</span>

<span class="sd">Aglyph recognizes the following lifecycle states:</span>

<span class="sd">.. rubric:: &quot;after_inject&quot;</span>

<span class="sd">A component object is in this state after **all** dependencies (both</span>
<span class="sd">initialization arguments and attributes) have been injected into a</span>
<span class="sd">newly-created instance, but before the object is cached and/or returned</span>
<span class="sd">to the caller.</span>

<span class="sd">Aglyph will only call **one** &quot;after_inject&quot; method on any object, and</span>
<span class="sd">will determine which method to call by using the lookup process</span>
<span class="sd">described below.</span>

<span class="sd">.. rubric:: &quot;before_clear&quot;</span>

<span class="sd">A component object is in this state after is has been removed from an</span>
<span class="sd">internal cache (singleton, borg, or weakref), but before the object</span>
<span class="sd">itself is actually discarded.</span>

<span class="sd">Aglyph will only call **one** &quot;before_clear&quot; method on any object, and</span>
<span class="sd">will determine which method to call by using the lookup process</span>
<span class="sd">described below.</span>

<span class="sd">.. _lifecycle-method-lookup-process:</span>

<span class="sd">.. rubric:: The lifecycle method lookup process</span>

<span class="sd">Lifecyle methods may be specified at the context (least specific),</span>
<span class="sd">template, and component (most specific) levels.</span>

<span class="sd">In order to determine which named method is called for a particular</span>
<span class="sd">object, Aglyph looks up the appropriate lifecycle method name in the</span>
<span class="sd">following order, using the **first** one found that is not ``None``</span>
<span class="sd">*and* is actually defined on the object:</span>

<span class="sd">#. The method named by the object&#39;s ``Component.&lt;lifecycle-state&gt;``</span>
<span class="sd">   property.</span>
<span class="sd">#. If the object&#39;s :attr:`Component.parent_id` is not ``None``, the</span>
<span class="sd">   method named by the corresponding parent</span>
<span class="sd">   ``Template.&lt;lifecycle-state&gt;`` or ``Component.&lt;lifecycle-state&gt;``</span>
<span class="sd">   property. (If necessary, lookup continues by examining the</span>
<span class="sd">   parent-of-the-parent and so on.)</span>
<span class="sd">#. The method named by the ``Context.&lt;lifecycle-state&gt;`` property.</span>

<span class="sd">When Aglyph finds a named lifecycle method that applies to an object,</span>
<span class="sd">but the object itself does not define that method, a</span>
<span class="sd">:attr:`logging.WARNING` message is emitted.</span>

<span class="sd">.. note::</span>
<span class="sd">  Either a :class:`Component` or :attr:`Template` may serve as the</span>
<span class="sd">  parent identified by a ``parent_id``.</span>

<span class="sd">  However, only a :class:`Component` may actually be assembled into</span>
<span class="sd">  a usable object. (A :attr:`Template` is like an abstract class -</span>
<span class="sd">  it defines common dependencies and/or lifecycle methods, but it</span>
<span class="sd">  cannot be assembled.)</span>

<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="Reference"><a class="viewcode-back" href="../../aglyph.component.html#aglyph.component.Reference">[docs]</a><span class="k">class</span> <span class="nc">Reference</span><span class="p">(</span><span class="n">TextType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A placeholder used to refer to another :class:`Component`.</span>

<span class="sd">    A ``Reference`` is used as an alias to identify a component that is</span>
<span class="sd">    a dependency of another component. The value of a ``Reference`` can</span>
<span class="sd">    be either a dotted-name or a user-provided unique ID.</span>

<span class="sd">    A ``Reference`` can be used as an argument for an</span>
<span class="sd">    :class:`Evaluator`, and can be assembled directly by an</span>
<span class="sd">    :class:`aglyph.assembler.Assembler`.</span>

<span class="sd">    .. warning::</span>
<span class="sd">       A ``Reference`` value MUST correspond to a component ID in the</span>
<span class="sd">       same context.</span>

<span class="sd">    .. note::</span>
<span class="sd">        In Python versions &lt; 3.0, a ``Reference`` representing a</span>
<span class="sd">        dotted-name *must* consist only of characters in the ASCII</span>
<span class="sd">        subset of the source encoding (see :pep:`0263`).</span>

<span class="sd">        But in Python versions &gt;= 3.0, a ``Reference`` representing a</span>
<span class="sd">        dotted-name *may* contain non-ASCII characters</span>
<span class="sd">        (see :pep:`3131`).</span>

<span class="sd">        However, a ``Reference`` may also represent a user-defined</span>
<span class="sd">        identifier. To accommodate all cases, the super class of</span>
<span class="sd">        ``Reference`` is &quot;dynamic&quot; with respect to the version of Python</span>
<span class="sd">        under which Aglyph is running (:class:`unicode` under Python 2,</span>
<span class="sd">        :class:`str` under Python 3). This documentation shows the base</span>
<span class="sd">        class as ``str`` because the `Sphinx &lt;http://sphinx-doc.org/&gt;`_</span>
<span class="sd">        documentation generator for Aglyph runs under CPython 3.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">referent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new reference to *referent*.</span>

<span class="sd">        :arg referent:</span>
<span class="sd">           the object that the reference will represent</span>
<span class="sd">        :raise aglyph.AglyphError:</span>
<span class="sd">           if *referent* is a class, function, or module but cannot be</span>
<span class="sd">           imported</span>

<span class="sd">        If *referent* is a string, it is assumed to be a valid</span>
<span class="sd">        :attr:`Component.unique_id` and its value is returned as a</span>
<span class="sd">        ``Reference``.</span>

<span class="sd">        If *referent* is a class, function, or module, its</span>
<span class="sd">        **importable** dotted name is returned as a ``Reference``.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           If *referent* is a class, function, or module, it **must**</span>
<span class="sd">           be importable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TextType</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_identify</span><span class="p">(</span><span class="n">referent</span><span class="p">))</span></div>


<span class="n">_log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reference extends </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">TextType</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_InitializationSupport</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The base for any class that configures type 2 (constructor)</span>
<span class="sd">    injection.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_args&quot;</span><span class="p">,</span> <span class="s2">&quot;_keywords&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The positional argument list and keyword argument mapping are</span>
<span class="sd">        initialized to empty.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#PYVER: arguments to super() are implicit under Python 3</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_InitializationSupport</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keywords</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The positional initialization arguments.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">keywords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The keyword initialization arguments.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keywords</span>


<div class="viewcode-block" id="Evaluator"><a class="viewcode-back" href="../../aglyph.component.html#aglyph.component.Evaluator">[docs]</a><span class="nd">@traced</span>
<span class="nd">@logged</span>
<span class="k">class</span> <span class="nc">Evaluator</span><span class="p">(</span><span class="n">_InitializationSupport</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform lazy creation of objects.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_factory&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param factory:</span>
<span class="sd">           any callable that returns an object</span>
<span class="sd">        :param tuple args:</span>
<span class="sd">           the positional arguments to *func*</span>
<span class="sd">        :param dict keywords:</span>
<span class="sd">           the keyword arguments to *func*</span>

<span class="sd">        An ``Evaluator`` is similar to a :func:`functools.partial` in</span>
<span class="sd">        that they both collect a function and related arguments into a</span>
<span class="sd">        :obj:`callable` object with a simplified signature that can be</span>
<span class="sd">        called repeatedly to produce a new object.</span>

<span class="sd">        *Unlike* a partial function, an ``Evaluator`` may have arguments</span>
<span class="sd">        that are not truly &quot;frozen,&quot; in the sense that any argument may</span>
<span class="sd">        be defined as a :class:`Reference`, a :func:`functools.partial`,</span>
<span class="sd">        or even another ``Evaluator``, which needs to be resolved (i.e.</span>
<span class="sd">        assembled/called) before calling *factory*.</span>

<span class="sd">        When an ``Evaluator`` is called, its arguments (positional and</span>
<span class="sd">        keyword) are each resolved in one of the following ways:</span>

<span class="sd">        * If the argument value is a :class:`Reference`, it is assembled</span>
<span class="sd">          (by an :class:`aglyph.assembler.Assembler` reference passed to</span>
<span class="sd">          :meth:`__call__`)</span>
<span class="sd">        * If the argument value is an ``Evaluator`` or a</span>
<span class="sd">          :func:`functools.partial`, it is called to produce its value.</span>
<span class="sd">        * If the argument is a dictionary or a sequence other than a</span>
<span class="sd">          string type, each item is resolved according to these rules.</span>
<span class="sd">        * If none of the above cases apply, the argument value is used</span>
<span class="sd">          as-is.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#PYVER: arguments to super() are implicit under Python 3</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Evaluator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">factory</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> is not callable&quot;</span> <span class="o">%</span> <span class="n">factory</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_factory</span> <span class="o">=</span> <span class="n">factory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="c1"># mutable args for _InitializationSupport</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keywords</span> <span class="o">=</span> <span class="n">keywords</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :obj:`callable` that creates new objects *(read-only)*.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factory</span>

<div class="viewcode-block" id="Evaluator.__call__"><a class="viewcode-back" href="../../aglyph.component.html#aglyph.component.Evaluator.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assembler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call ``factory(*args, **keywords)`` and return the new object.</span>

<span class="sd">        :param aglyph.assembly.Assembler assembler:</span>
<span class="sd">           the assembler that will be used to assemble any</span>
<span class="sd">           :class:`Reference` encountered in this evaluator&#39;s positional</span>
<span class="sd">           and keyword arguments</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve</span>
        <span class="n">resolved_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">resolve</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">assembler</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">)</span>
        <span class="c1"># keywords MUST be strings!</span>
        <span class="n">resolved_keywords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">resolve</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">assembler</span><span class="p">))</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keywords</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factory</span><span class="p">(</span><span class="o">*</span><span class="n">resolved_args</span><span class="p">,</span> <span class="o">**</span><span class="n">resolved_keywords</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">assembler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the resolved *arg*.</span>

<span class="sd">        :param arg:</span>
<span class="sd">           represents an argument (positional or keyword) to</span>
<span class="sd">           :attr:`factory`</span>
<span class="sd">        :param aglyph.assembly.Assembler assembler:</span>
<span class="sd">           the assembler that will be used to resolve *arg*</span>
<span class="sd">        :return:</span>
<span class="sd">           the resolved argument value that will actually be passed to</span>
<span class="sd">           :attr:`factory`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Reference</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">assembler</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Evaluator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">arg</span><span class="p">(</span><span class="n">assembler</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">partial</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">arg</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># either keys or values may themselves be References, partials, or</span>
            <span class="c1"># Evaluators</span>
            <span class="n">resolve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">resolve</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">assembler</span><span class="p">),</span> <span class="n">resolve</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">assembler</span><span class="p">))</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_string</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">resolve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve</span>
            <span class="c1"># assumption: the iterable class supports initialization with</span>
            <span class="c1"># __init__(iterable)</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">resolve</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">assembler</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arg</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> @</span><span class="si">%08x</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">name_of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factory</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">(</span><span class="si">%r</span><span class="s2">, *</span><span class="si">%r</span><span class="s2"> **</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="n">name_of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_factory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keywords</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_DependencySupport</span><span class="p">(</span><span class="n">_InitializationSupport</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The base for any class that configures both type 1 (setter) and</span>
<span class="sd">    type 2 (constructor) injection.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_attributes&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The field/property/setter mapping is initialized to empty.&quot;&quot;&quot;</span>
        <span class="c1">#PYVER: arguments to super() are implicit under Python 3</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_DependencySupport</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The field/property/setter mapping.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span>


<div class="viewcode-block" id="Template"><a class="viewcode-back" href="../../aglyph.component.html#aglyph.component.Template">[docs]</a><span class="nd">@traced</span>
<span class="nd">@logged</span>
<span class="k">class</span> <span class="nc">Template</span><span class="p">(</span><span class="n">_DependencySupport</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Support for configuring type 1 (setter) and type 2 (constructor)</span>
<span class="sd">    injection, and lifecycle methods.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_after_inject&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_before_clear&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_parent_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_unique_id&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">unique_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">after_inject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">before_clear</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg str unique_id:</span>
<span class="sd">           context-unique identifier for this template</span>
<span class="sd">        :keyword str parent_id:</span>
<span class="sd">           specifies the ID of a template or component that describes</span>
<span class="sd">           the default dependencies and/or lifecyle methods for this</span>
<span class="sd">           template</span>
<span class="sd">        :keyword str after_inject:</span>
<span class="sd">           specifies the name of the method that will be called on</span>
<span class="sd">           objects of components that reference this template after all</span>
<span class="sd">           component dependencies have been injected</span>
<span class="sd">        :keyword str before_clear:</span>
<span class="sd">           specifies the name of the method that will be called on</span>
<span class="sd">           objects of components that reference this template</span>
<span class="sd">           immediately before they are cleared from cache</span>
<span class="sd">        :raise ValueError:</span>
<span class="sd">           if *unique_id* is ``None`` or empty</span>

<span class="sd">        .. note::</span>
<span class="sd">           A ``Template`` cannot be assembled (it is equivalent to an</span>
<span class="sd">           abstract class).</span>

<span class="sd">           However, a :class:`Component` can also serve as a template,</span>
<span class="sd">           so if you need the ability to assemble an object *and* use</span>
<span class="sd">           its definition as the basis for other components, then define</span>
<span class="sd">           the default dependencies and/or lifecycle methods in a</span>
<span class="sd">           :class:`Component` and use that component&#39;s ID as the</span>
<span class="sd">           :attr:`Component.parent_id` in other components.</span>

<span class="sd">        *unique_id* must be a user-provided identifier that is unique</span>
<span class="sd">        within the context to which this template is added. A component</span>
<span class="sd">        may then be instructed to use a template by specifying the same</span>
<span class="sd">        value for :attr:`Component.parent_id`.</span>

<span class="sd">        *parent_id* is **another** :attr:`Component.unique_id` or</span>
<span class="sd">        :attr:`Template.unique_id` in the same context that descibes</span>
<span class="sd">        **this** template&#39;s default dependencies and/or lifecycle</span>
<span class="sd">        methods.</span>

<span class="sd">        *after_inject* is the name of a method *of objects of this</span>
<span class="sd">        component* that will be called after **all** dependencies have</span>
<span class="sd">        been injected, but before the object is returned to the caller.</span>
<span class="sd">        This method will be called with **no** arguments (positional or</span>
<span class="sd">        keyword). Exceptions raised by this method are not caught.</span>

<span class="sd">        .. note::</span>
<span class="sd">           ``Template.after_inject`` takes precedence over any</span>
<span class="sd">           *after_inject* method name specified for the template&#39;s</span>
<span class="sd">           parent or context.</span>

<span class="sd">        *before_clear* is the name of a method *of objects of this</span>
<span class="sd">        component* that will be called immediately before the object is</span>
<span class="sd">        cleared from cache via</span>
<span class="sd">        :meth:`aglyph.assembler.Assembler.clear_singletons()`,</span>
<span class="sd">        :meth:`aglyph.assembler.Assembler.clear_borgs()`, or</span>
<span class="sd">        :meth:`aglyph.assembler.Assembler.clear_weakrefs()`.</span>

<span class="sd">        .. note::</span>
<span class="sd">           ``Template.before_clear`` takes precedence over any</span>
<span class="sd">           *before_clear* method name specified for the template&#39;s</span>
<span class="sd">           parent or context.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           The *before_clear* keyword argument has no meaning for and is</span>
<span class="sd">           ignored by &quot;prototype&quot; components. If *before_clear* is</span>
<span class="sd">           specified for a prototype, a :class:`RuntimeWarning` will be</span>
<span class="sd">           issued.</span>

<span class="sd">           For &quot;weakref&quot; components, there is a possibility that the</span>
<span class="sd">           object no longer exists at the moment when the *before_clear*</span>
<span class="sd">           method would be called. In such cases, the *before_clear*</span>
<span class="sd">           method is **not** called. No warning is issued, but a</span>
<span class="sd">           :attr:`logging.WARNING` message is emitted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#PYVER: arguments to super() are implicit under Python 3</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Template</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">unique_id</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> unique ID must not be None or empty&quot;</span> <span class="o">%</span>
                    <span class="n">name_of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_id</span> <span class="o">=</span> <span class="n">unique_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_id</span> <span class="o">=</span> <span class="n">parent_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_after_inject</span> <span class="o">=</span> <span class="n">after_inject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_before_clear</span> <span class="o">=</span> <span class="n">before_clear</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unique_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Uniquely identifies this template in a context *(read-only)*.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parent_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Identifies this template&#39;s parent template or component</span>
<span class="sd">        *(read-only)*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">after_inject</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the component object method that will be called</span>
<span class="sd">        after **all** dependencies have been injected *(read-only)*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_after_inject</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">before_clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the component object method that will be called</span>
<span class="sd">        immediately before the object is cleared from cache</span>
<span class="sd">        *(read-only)*.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           This property is not applicable to &quot;prototype&quot; component</span>
<span class="sd">           objects, and is **not guaranteed** to be called for &quot;weakref&quot;</span>
<span class="sd">           component objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_clear</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2"> @</span><span class="si">%08x</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">name_of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_id</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">(</span><span class="si">%r</span><span class="s2">, parent_id=</span><span class="si">%r</span><span class="s2">, after_inject=</span><span class="si">%r</span><span class="s2">, before_clear=</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="n">name_of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unique_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_after_inject</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_before_clear</span><span class="p">)</span></div>


<div class="viewcode-block" id="Component"><a class="viewcode-back" href="../../aglyph.component.html#aglyph.component.Component">[docs]</a><span class="nd">@traced</span>
<span class="nd">@logged</span>
<span class="k">class</span> <span class="nc">Component</span><span class="p">(</span><span class="n">Template</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define a component and the dependencies needed to create a new</span>
<span class="sd">    object of that component at runtime.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_dotted_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_factory_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_member_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_strategy&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">component_id</span><span class="p">,</span> <span class="n">dotted_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">factory_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">member_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">parent_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">after_inject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">before_clear</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :arg str component_id:</span>
<span class="sd">           the context-unique identifier for this component</span>
<span class="sd">        :keyword str dotted_name:</span>
<span class="sd">           an **importable** dotted name</span>
<span class="sd">        :keyword str factory_name:</span>
<span class="sd">           names a :obj:`callable` member of objects of this component</span>
<span class="sd">        :keyword str member_name:</span>
<span class="sd">           names **any** member of objects of this component</span>
<span class="sd">        :keyword str strategy:</span>
<span class="sd">           specifies the component assembly strategy</span>
<span class="sd">        :keyword str parent_id:</span>
<span class="sd">           specifies the ID of a template or component that describes</span>
<span class="sd">           the default dependencies and/or lifecyle methods for this</span>
<span class="sd">           component</span>
<span class="sd">        :keyword str after_inject:</span>
<span class="sd">           specifies the name of the method that will be called on</span>
<span class="sd">           objects of this component after all of its dependencies have</span>
<span class="sd">           been injected</span>
<span class="sd">        :keyword str before_clear:</span>
<span class="sd">           specifies the name of the method that will be called on</span>
<span class="sd">           objects of this component immediately before they are cleared</span>
<span class="sd">           from cache</span>
<span class="sd">        :raise aglyph.AglyphError:</span>
<span class="sd">           if both *factory_name* and *member_name* are specified</span>
<span class="sd">        :raise ValueError:</span>
<span class="sd">           if *strategy* is not a recognized assembly strategy</span>

<span class="sd">        *component_id* must be a user-provided identifier that is unique</span>
<span class="sd">        within the context to which this component is added. An</span>
<span class="sd">        **importable** dotted name may be used (see</span>
<span class="sd">        :func:`aglyph.resolve_dotted_name`).</span>

<span class="sd">        *dotted_name*, if provided, must be an **importable** dotted</span>
<span class="sd">        name (see :func:`aglyph.resolve_dotted_name`).</span>

<span class="sd">        .. note::</span>
<span class="sd">           If *dotted_name* is not specified, then *component_id* is</span>
<span class="sd">           used as the component&#39;s dotted name and **must** be an</span>
<span class="sd">           importable dotted name.</span>

<span class="sd">        *factory_name* is the name of a :obj:`callable` member of</span>
<span class="sd">        *dotted-name* (i.e. a function, class, staticmethod, or</span>
<span class="sd">        classmethod). When provided, the assembler will call this member</span>
<span class="sd">        to create an object of this component.</span>

<span class="sd">        *factory_name* enables Aglyph to inject dependencies into</span>
<span class="sd">        objects that can only be initialized via nested classes,</span>
<span class="sd">        :obj:`staticmethod`, or :obj:`classmethod`. See</span>
<span class="sd">        :attr:`factory_name` for details.</span>

<span class="sd">        *member_name* is the name of a member of *dotted-name*, which</span>
<span class="sd">        **may or may not** be callable.</span>

<span class="sd">        *member_name* differs from *factory_name* in two ways:</span>

<span class="sd">        1. *member_name* is not restricted to callable members; it may</span>
<span class="sd">           identify **any** member (attribute, property, nested class).</span>
<span class="sd">        2. When an assembler assembles a component with a</span>
<span class="sd">           *member_name*, initialization of the object is *bypassed*</span>
<span class="sd">           (i.e. the assembler will not call the member, and any</span>
<span class="sd">           initialization arguments defined for the component will be</span>
<span class="sd">           **ignored**).</span>

<span class="sd">        *member_name* enables Aglyph to reference class, function,</span>
<span class="sd">        :obj:`staticmethod`, and :obj:`classmethod` obejcts, as well as</span>
<span class="sd">        simple attributes or properties, as components and dependencies.</span>
<span class="sd">        See :attr:`member_name` for details.</span>

<span class="sd">        .. note::</span>

<span class="sd">           Both *factory_name* and *member_name* can be dot-separated</span>
<span class="sd">           names to reference nested members.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           The *factory_name* and *member_name* arguments are mutually</span>
<span class="sd">           exclusive. An exception is raised if both are provided.</span>

<span class="sd">        *strategy* must be a recognized component assembly strategy, and</span>
<span class="sd">        defaults to ``Strategy.PROTOTYPE`` (*&quot;prototype&quot;*) if not</span>
<span class="sd">        specified.</span>

<span class="sd">        .. versionadded:: 3.0.0</span>
<span class="sd">           When :attr:`member_name` is specified, the strategy **must**</span>
<span class="sd">           be *&quot;_imported&quot;*. Aglyph will use the &quot;_imported&quot; strategy</span>
<span class="sd">           automatically for components that specify *member_name*;</span>
<span class="sd">           setting strategy to anything other than &quot;_imported&quot; when</span>
<span class="sd">           specifying *member_name* will issue :class:`UserWarning`.</span>

<span class="sd">        Please see :data:`Strategy` for a description of the component</span>
<span class="sd">        assembly strategies supported by Aglyph.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           The ``Strategy.BORG`` (*&quot;borg&quot;*) component assembly strategy</span>
<span class="sd">           is only supported for classes that **do not** define or</span>
<span class="sd">           inherit ``__slots__``!</span>

<span class="sd">        *parent_id* is the context-unique ID of a :class:`Template` (or</span>
<span class="sd">        another ``Component``) that defines default dependencies and/or</span>
<span class="sd">        lifecycle methods for this component.</span>

<span class="sd">        *after_inject* is the name of a method *of objects of this</span>
<span class="sd">        component* that will be called after **all** dependencies have</span>
<span class="sd">        been injected, but before the object is returned to the caller.</span>
<span class="sd">        This method will be called with **no** arguments (positional or</span>
<span class="sd">        keyword). Exceptions raised by this method are not caught.</span>

<span class="sd">        .. note::</span>
<span class="sd">           ``Component.after_inject`` takes precedence over any</span>
<span class="sd">           *after_inject* method names specified for the component&#39;s</span>
<span class="sd">           parent or context.</span>

<span class="sd">        *before_clear* is the name of a method *of objects of this</span>
<span class="sd">        component* that will be called immediately before the object is</span>
<span class="sd">        cleared from cache via</span>
<span class="sd">        :meth:`aglyph.assembler.Assembler.clear_singletons()`,</span>
<span class="sd">        :meth:`aglyph.assembler.Assembler.clear_borgs()`, or</span>
<span class="sd">        :meth:`aglyph.assembler.Assembler.clear_weakrefs()`.</span>

<span class="sd">        .. note::</span>
<span class="sd">           ``Component.before_clear`` takes precedence over any</span>
<span class="sd">           *before_clear* method names specified for the component&#39;s</span>
<span class="sd">           parent or context.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           The *before_clear* keyword argument has no meaning for, and</span>
<span class="sd">           is ignored by, &quot;prototype&quot; components. If *before_clear* is</span>
<span class="sd">           specified for a prototype component, a :class:`UserWarning`</span>
<span class="sd">           is issued **when the component is defined**, and the</span>
<span class="sd">           component&#39;s :attr:`before_clear` attribute is set to</span>
<span class="sd">           ``None``.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           For &quot;weakref&quot; components, there is a possibility that the</span>
<span class="sd">           object no longer exists at the moment when the *before_clear*</span>
<span class="sd">           method would be called. In such cases, the</span>
<span class="sd">           :meth:`aglyph.assembler.clear_weakrefs` method will issue a</span>
<span class="sd">           :class:`RuntimeWarning` (see that method&#39;s documentation for</span>
<span class="sd">           more details).</span>

<span class="sd">        Once a ``Component`` instance is initialized, the ``args``</span>
<span class="sd">        (:obj:`list`), ``keywords`` (:obj:`dict`), and ``attributes``</span>
<span class="sd">        (:class:`collections.OrderedDict`) members can be modified</span>
<span class="sd">        in-place to define the dependencies that must be injected into</span>
<span class="sd">        objects of this component at assembly time. For example::</span>

<span class="sd">           component = Component(&quot;http.client.HTTPConnection&quot;)</span>
<span class="sd">           component.args.append(&quot;ninthtest.info&quot;)</span>
<span class="sd">           component.args.append(80)</span>
<span class="sd">           component.keywords[&quot;strict&quot;] = True</span>
<span class="sd">           component.attributes[&quot;set_debuglevel&quot;] = 1</span>

<span class="sd">        In Aglyph, a component may:</span>

<span class="sd">        * be assembled directly by an</span>
<span class="sd">          :class:`aglyph.assembler.Assembler`</span>
<span class="sd">        * identify other components as dependencies (using a</span>
<span class="sd">          :class:`Reference`)</span>
<span class="sd">        * be used by other components as a dependency</span>
<span class="sd">        * use common dependencies and behaviors (*after_inject*,</span>
<span class="sd">          *before_clear*) defined in a</span>
<span class="sd">          :class:`aglyph.component.Template`</span>
<span class="sd">        * use any combination of the above behaviors</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#PYVER: arguments to super() are implicit under Python 3</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Component</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">component_id</span><span class="p">,</span> <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span><span class="p">,</span>
            <span class="n">after_inject</span><span class="o">=</span><span class="n">after_inject</span><span class="p">,</span> <span class="n">before_clear</span><span class="o">=</span><span class="n">before_clear</span><span class="p">)</span>

        <span class="c1"># if a dotted name is not provided, the unique ID is assumed to be a</span>
        <span class="c1"># dotted name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dotted_name</span> <span class="o">=</span> <span class="n">dotted_name</span> <span class="k">if</span> <span class="n">dotted_name</span> <span class="k">else</span> <span class="n">component_id</span>

        <span class="k">if</span> <span class="n">factory_name</span> <span class="ow">and</span> <span class="n">member_name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AglyphError</span><span class="p">(</span>
                <span class="s2">&quot;only one of factory_name or member_name may be specified&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_factory_name</span> <span class="o">=</span> <span class="n">factory_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_member_name</span> <span class="o">=</span> <span class="n">member_name</span>

        <span class="c1"># issues/5: default strategy is &quot;_imported&quot; when member_name is</span>
        <span class="c1"># specified, otherwise &quot;prototype&quot;</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> \
                <span class="s2">&quot;_imported&quot;</span> <span class="k">if</span> <span class="n">member_name</span> <span class="k">else</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">PROTOTYPE</span>

        <span class="c1"># issues/5: member_name requires &quot;_imported&quot; strategy and vice-versa</span>
        <span class="k">if</span> <span class="n">member_name</span> <span class="ow">and</span> <span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;_imported&quot;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;ignoring strategy </span><span class="si">%r</span><span class="s2"> for component </span><span class="si">%r</span><span class="s2"> -- strategy MUST be &quot;</span>
                <span class="s2">&quot;&#39;_imported&#39; (implicit) if member_name is specified&quot;</span><span class="p">)</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="n">component_id</span><span class="p">),</span>
                <span class="ne">UserWarning</span><span class="p">)</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="s2">&quot;_imported&quot;</span>
        <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;_imported&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">member_name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AglyphError</span><span class="p">(</span>
                <span class="s2">&quot;strategy &#39;_imported&#39; is only valid if member_name is specified&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">strategy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Strategy</span> <span class="ow">and</span> <span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;_imported&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unrecognized assembly strategy </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">strategy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="n">strategy</span>

        <span class="c1"># issues/5: also see Assembler._call_lifecycle_method, which issues a</span>
        <span class="c1"># RuntimeWarning for _imported components that describe an after_inject</span>
        <span class="c1"># method</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strategy</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Strategy</span><span class="o">.</span><span class="n">PROTOTYPE</span><span class="p">,</span> <span class="s2">&quot;_imported&quot;</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">before_clear</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;ignoring before_clear=</span><span class="si">%r</span><span class="s2"> for </span><span class="si">%s</span><span class="s2"> component with ID </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">before_clear</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_id</span><span class="p">),</span>
                <span class="ne">UserWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_before_clear</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dotted_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The importable dotted name for objects of this component</span>
<span class="sd">        *(read-only)*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dotted_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factory_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of a :obj:`callable` member of :attr:`dotted_name`</span>
<span class="sd">        *(read-only)*.</span>

<span class="sd">        ``factory_name`` can be used to initialize objects of the</span>
<span class="sd">        component when a class is not directly importable (e.g. the</span>
<span class="sd">        component class is a nested class), or when component objects</span>
<span class="sd">        need to be initialized via :obj:`staticmethod` or</span>
<span class="sd">        :obj:`classmethod`.</span>

<span class="sd">        Consider the following::</span>

<span class="sd">           # module.py</span>
<span class="sd">           class Example:</span>
<span class="sd">               class Nested:</span>
<span class="sd">                   pass</span>

<span class="sd">        The dotted name &quot;module.Example.Nested&quot; is not importable, and</span>
<span class="sd">        so cannot be used as a component&#39;s ``unique_id`` or</span>
<span class="sd">        ``dotted_name``. To assemble objects of this type, use</span>
<span class="sd">        ``factory_name`` to identify the callable factory (the Nested</span>
<span class="sd">        class, in this example) that is accessible through the</span>
<span class="sd">        importable &quot;module.Example&quot;::</span>

<span class="sd">           component = Component(</span>
<span class="sd">               &quot;nested-object&quot;, dotted_name=&quot;module.Example&quot;,</span>
<span class="sd">               factory_name=&quot;Nested&quot;)</span>

<span class="sd">        Or using XML configuration::</span>

<span class="sd">           &lt;component id=&quot;nested-object&quot; dotted-name=&quot;module.Example&quot;</span>
<span class="sd">               factory-name=&quot;Nested&quot; /&gt;</span>

<span class="sd">        ``factory_name`` may also be a dot-separated name to specify an</span>
<span class="sd">        arbitrarily-nested callable. The following example is equivalent</span>
<span class="sd">        to the above::</span>

<span class="sd">           component = Component(</span>
<span class="sd">               &quot;nested-object&quot;, dotted_name=&quot;module&quot;,</span>
<span class="sd">               factory_name=&quot;Example.Nested&quot;)</span>

<span class="sd">        Or again using XML configuration::</span>

<span class="sd">           &lt;component id=&quot;nested-object&quot; dotted-name=&quot;module&quot;</span>
<span class="sd">               factory-name=&quot;Example.Nested&quot; /&gt;</span>

<span class="sd">        .. note::</span>
<span class="sd">           The important thing to remember is that :attr:`dotted_name`</span>
<span class="sd">           must be **importable**, and ``factory_name`` must be</span>
<span class="sd">           accessible from the imported class or module via attribute</span>
<span class="sd">           access.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factory_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">member_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of any member of :attr:`dotted_name` *(read-only)*.</span>

<span class="sd">        ``member_name`` can be used to obtain an object *directly* from</span>
<span class="sd">        an importable module or class. The named member is simply</span>
<span class="sd">        accessed and returned (it is **not** called, even if it is</span>
<span class="sd">        callable).</span>

<span class="sd">        Consider the following::</span>

<span class="sd">           # module.py</span>
<span class="sd">           class Example:</span>
<span class="sd">               class Nested:</span>
<span class="sd">                   pass</span>

<span class="sd">        The following example shows how to define a component that will</span>
<span class="sd">        produce the ``module.Example.Nested`` class *itself* when</span>
<span class="sd">        assembled::</span>

<span class="sd">           component = Component(</span>
<span class="sd">               &quot;nested-class&quot;, dotted_name=&quot;module.Example&quot;,</span>
<span class="sd">               member_name=&quot;Nested&quot;)</span>

<span class="sd">        Or using XML configuration::</span>

<span class="sd">           &lt;component id=&quot;nested-class&quot; dotted-name=&quot;module.Example&quot;</span>
<span class="sd">               member-name=&quot;Nested&quot; /&gt;</span>

<span class="sd">        ``member_name`` may also be a dot-separated name to specify an</span>
<span class="sd">        arbitrarily-nested member. The following example is equivalent</span>
<span class="sd">        to the above::</span>

<span class="sd">           component = Component(</span>
<span class="sd">               &quot;nested-class&quot;, dotted_name=&quot;module&quot;,</span>
<span class="sd">               member_name=&quot;Example.Nested&quot;)</span>

<span class="sd">        Or again using XML configuration::</span>

<span class="sd">           &lt;component id=&quot;nested-class&quot; dotted-name=&quot;module&quot;</span>
<span class="sd">               member-name=&quot;Example.Nested&quot; /&gt;</span>

<span class="sd">        .. note::</span>
<span class="sd">           The important thing to remember is that :attr:`dotted_name`</span>
<span class="sd">           must be **importable**, and ``member_name`` must be</span>
<span class="sd">           accessible from the imported class or module via attribute</span>
<span class="sd">           access.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           When a component specifies ``member_name``, initialization is</span>
<span class="sd">           assumed. In other words, Aglyph **will not** attempt to</span>
<span class="sd">           initialize the member, and will **ignore** any :attr:`args`</span>
<span class="sd">           and :attr:`keywords`.</span>

<span class="sd">           On assembly, if any initialization arguments and/or keyword</span>
<span class="sd">           arguments have been defined for such a component, they are</span>
<span class="sd">           discarded and a WARNING-level log record is emitted to the</span>
<span class="sd">           &quot;aglyph.assembler.Assembler&quot; channel.</span>

<span class="sd">           (Any :attr:`attributes` that have been specified for the</span>
<span class="sd">           component will still be processed as setter injection</span>
<span class="sd">           dependencies, however.)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_member_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The component assembly strategy *(read-only)*.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">(</span><span class="si">%r</span><span class="s2">, dotted_name=</span><span class="si">%r</span><span class="s2">, factory_name=</span><span class="si">%r</span><span class="s2">, member_name=</span><span class="si">%r</span><span class="s2">, &quot;</span>
            <span class="s2">&quot;strategy=</span><span class="si">%r</span><span class="s2">, parent_id=</span><span class="si">%r</span><span class="s2">, after_inject=</span><span class="si">%r</span><span class="s2">, before_clear=</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="n">name_of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unique_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dotted_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factory_name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_member_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_id</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_after_inject</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_clear</span><span class="p">)</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Aglyph</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../whats-new.html">Whats new in release 3.0.0.post1?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../get-started.html">Getting started with Aglyph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cookbook.html">Aglyph cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-ref.html">Aglyph API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../context-fluent-api.html">The Aglyph Context fluent API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing.html">Aglyph 3.0.0.post1 testing summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roadmap.html">Roadmap for future releases</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../aglyph.html">aglyph</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2006, 2011, 2013-2018 Matthew Zipay.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.8</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
    </div>

    

    
  </body>
</html>