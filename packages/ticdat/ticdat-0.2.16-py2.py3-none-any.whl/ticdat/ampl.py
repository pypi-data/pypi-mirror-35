from ticdat.utils import verify, containerish, stringish, find_duplicates_from_dict_ticdat
from ticdat.utils import find_case_space_duplicates, change_fields_with_reserved_keywords
import ticdat.utils as tu
from ticdat.ticdatfactory import TicDatFactory
import os, subprocess, inspect, time, uuid, shutil
from collections import defaultdict
from ticdat.jsontd import make_json_dict
from amplpy import AMPL

INFINITY = 999999 # Does AMPL have a way to mark infinity?

ampl_keywords = ["I imagine this will come up eventually"]

def _code_dir():
    return os.path.dirname(os.path.abspath(inspect.getsourcefile(_code_dir)))

def _fix_fields_with_ampl_keywords(tdf):
    return change_fields_with_reserved_keywords(tdf, ampl_keywords)

def _unfix_fields_with_ampl_keywords(tdf):
    return change_fields_with_reserved_keywords(tdf, ampl_keywords, True)

def ampl_run(mod_file, input_tdf, input_dat, soln_tdf, infinity=INFINITY, post_solve=None):
    """
    solve an optimization problem using an AMPL .mod file
    :param mod_file: An AMPL .mod file.
    :param input_tdf: A TicDatFactory defining the input schema
    :param input_dat: A TicDat object consistent with input_tdf
    :param soln_tdf: A TicDatFactory defining the solution variables
    :param infinity: A number used to represent infinity in AMPL
    :return: a TicDat object consistent with soln_tdf, or None if no solution found
    """
    verify(os.path.isfile(mod_file), "mod_file %s is not a valid file." % mod_file)
    verify(not find_case_space_duplicates(input_tdf), "There are case space duplicate field names in the input schema.")
    verify(not find_case_space_duplicates(soln_tdf),
           "There are case space duplicate field names in the solution schema.")
    verify(len({input_tdf.ampl_prepend + t for t in input_tdf.all_tables}.union(
        {soln_tdf.ampl_prepend + t for t in soln_tdf.all_tables})) ==
           len(input_tdf.all_tables) + len(soln_tdf.all_tables),
           "There are colliding input and solution table names.\nSet ampl_prepend so " +
           "as to insure the input and solution table names are effectively distinct.")
    msg = []
    verify(input_tdf.good_tic_dat_object(input_dat, msg.append),
           "tic_dat not a good object for the input_tdf factory : %s" % "\n".join(msg))
    verify('TICDAT_AMPL_SOLVER_PATH' in os.environ.keys(),
           "TICDAT_AMPL_SOLVER_PATH environment variable is not set. Set it to"
           " the path of the solver you want to use.")
    verify(os.path.isfile(os.environ["TICDAT_AMPL_SOLVER_PATH"]), "%s is not a valid file. Set it to the path of the "
                                                              "solver you want to use." % os.environ["TICDAT_AMPL_SOLVER_PATH"])
    selected_solver = os.environ.get("TICDAT_AMPL_SOLVER_PATH", "FAILED_TO_RESOLVE")
    ampl = AMPL()
    ampl.setOption('solver', selected_solver)
    orig_input_tdf, orig_soln_tdf = input_tdf, soln_tdf
    input_tdf = _fix_fields_with_ampl_keywords(input_tdf)
    soln_tdf = _fix_fields_with_ampl_keywords(soln_tdf)
    input_dat = input_tdf.TicDat(**make_json_dict(orig_input_tdf, input_dat))
    assert input_tdf.good_tic_dat_object(input_dat)
    mod_file_name = os.path.basename(mod_file)[:-4]
    with open(mod_file, "r") as f:
        mod = f.read()
        assert ("ticdat_" + mod_file_name + ".mod") in mod
    working_dir = os.path.abspath(os.path.dirname(mod_file))
    if tu.development_deployed_environment:
        working_dir = os.path.join(working_dir, "amplticdat_%s" % uuid.uuid4())
        shutil.rmtree(working_dir, ignore_errors=True)
        os.mkdir(working_dir)
        working_dir = os.path.abspath(working_dir)
        _ = os.path.join(working_dir, os.path.basename(mod_file))
        shutil.copy(mod_file, _)
        mod_file = _
        ampl.cd(working_dir)
    datfile = os.path.join(working_dir, "ticdat_" + mod_file_name + ".dat")
    output_txt = os.path.join(working_dir, "output.txt")
    with open(datfile, "w") as f:
        f.write(create_ampl_text(input_tdf, input_dat, infinity))
    verify(os.path.isfile(datfile), "Could not create ticdat_{}.dat".format(mod_file_name))
    with open(os.path.join(working_dir, "ticdat_" + mod_file_name + ".mod"), "w") as f:
        f.write("/* Autogenerated input file, created by ampl.py on " + time.asctime() + " */\n")
        f.write(create_ampl_mod_text(orig_input_tdf))
    # raise Exception(os.path.isfile(os.path.join(working_dir,"ticdat_"+mod_file_name+".mod")))
    ampl.read(mod_file)
    ampl.readData(datfile)
    ampl.solve()
    results = {}
    for tbn in {t for t, pk in soln_tdf.primary_key_fields.items() if pk}:
        try:
            results[tbn] = ampl.getVariable(tbn).getValues().toList()
        except:
            print("Could not retrieve %s variable. A solution was likely not generated. Check AMPL output for details" % tbn)
            return None
    # Some condition needed for sln = None
    soln_tdf = _unfix_fields_with_ampl_keywords(soln_tdf)
    sln = soln_tdf.TicDat(**{k.replace(soln_tdf.ampl_prepend, "", 1): v for k, v in results.items()})
    return post_solve(sln) if post_solve else sln

_can_run_ampl_run_tests = True if 'TICDAT_AMPL_PATH' in os.environ else os.path.isfile(os.path.join(_code_dir(),"ampl_run_path.txt"))

def create_ampl_text(tdf, tic_dat, infinity=INFINITY):
    """
    Generate a AMPL .dat string from a TicDat object
    :param tdf: A TicDatFactory defining the schema
    :param tic_dat: A TicDat object consistent with tdf
    :param infinity: A number used to represent infinity in AMPL
    :return: A string consistent with the AMPL .dat format
    """
    msg = []
    verify(tdf.good_tic_dat_object(tic_dat, msg.append),
           "tic_dat not a good object for this factory : %s"%"\n".join(msg))
    verify(not tdf.generator_tables, "doesn't work with generator tables.")
    verify(not tdf.generic_tables, "doesn't work with generic tables. (not yet - will add ASAP as needed) ")
    dict_with_lists = defaultdict(list)
    dict_tables = {t for t,pk in tdf.primary_key_fields.items() if pk}
    for t in dict_tables:
        for k,r in getattr(tic_dat, t).items():
            row = list(k) if containerish(k) else [k]
            for f in tdf.data_fields.get(t, []):
                row.append(r[f])
            dict_with_lists[t].append(row)
    for t in set(tdf.all_tables).difference(dict_tables):
        for r in getattr(tic_dat, t):
            row = [r[f] for f in tdf.data_fields[t]]
            dict_with_lists[t].append(row)

    rtn = "data;\n"
    for i, (t,l) in enumerate(dict_with_lists.items()):
        rtn += "param: %s: "%(tdf.ampl_prepend + t)
        for field in tdf.data_fields[t]:
            rtn += "\"" + t + "_" + field.replace(" ", "_").lower() + "\" "
        rtn += ":=\n"
        for row in l:
            rtn += " "
            for field in row:
                rtn += ("\"%s\""%field if stringish(field) else (str(infinity) if float('inf') == field else str(field))) + " "
            rtn += "\n"
        rtn += ";\n"

    return rtn

def create_ampl_mod_text(tdf):
    """
    Generate a AMPL .mod string from a TicDat object for diagnostic purposes
    :param tdf: A TicDatFactory defining the input schema
    :return: A string consistent with the AMPL .mod input format
    """
    verify(not find_case_space_duplicates(tdf), "There are case space duplicate field names in the schema.")
    verify(not tdf.generator_tables, "Input schema error - doesn't work with generator tables.")
    verify(not tdf.generic_tables, "Input schema error - doesn't work with generic tables. (not yet - will \
            add ASAP as needed) ")
    tdf = _fix_fields_with_ampl_keywords(tdf)
    rtn = ''
    dict_tables = {t for t, pk in tdf.primary_key_fields.items() if pk}
    verify(set(dict_tables) == set(tdf.all_tables), "not yet handling non-PK tables of any sort")

    prepend = getattr(tdf, "ampl_prepend", "")

    def get_table_as_mod_text(tdf, tbn):
        p_tbn = prepend + tbn
        rtn = 'set ' + p_tbn
        if len(tdf.primary_key_fields[tbn]) > 1:
            rtn += ' dimen ' + str(len(tdf.primary_key_fields[tbn]))
        rtn += ';\n'
        for df in tdf.data_fields[tbn]:
            df_m = df.replace(' ', '_').lower()
            rtn += 'param ' + p_tbn + '_' + df_m + ' {' + p_tbn + '};\n'
        # Is this case a thing in ampl?
        # if len(tdf.primary_key_fields[tbn]) is 1 and len(tdf.data_fields[tbn]) is 0:
        return rtn

    for t in dict_tables:
        rtn += get_table_as_mod_text(tdf, t)

    return rtn