% Copyright (c) 2012-2018 by the GalSim developers team on GitHub
% https://github.com/GalSim-developers
%
% This file is part of GalSim: The modular galaxy image simulation toolkit.
% https://github.com/GalSim-developers/GalSim
%
% GalSim is free software: redistribution and use in source and binary forms,
% with or without modification, are permitted provided that the following
% conditions are met:
%
% 1. Redistributions of source code must retain the above copyright notice, this
%    list of conditions, and the disclaimer given in the accompanying LICENSE
%    file.
% 2. Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions, and the disclaimer given in the documentation
%    and/or other materials provided with the distribution.
%

\documentclass[preprint,10pt]{../../devel/modules/aastex}

% packages for figures
\usepackage{graphicx,times}
% packages for symbols
\usepackage{latexsym,amssymb,hyperref}
% AMS-LaTeX package for e.g. subequations
\usepackage{amsmath}
\usepackage{color}
\usepackage{tocloft}

% cf. http://tex.stackexchange.com/questions/299/how-to-get-long-texttt-sections-to-break
\newcommand*\justify{%
  \fontdimen2\font=0.4em% interword space
  \fontdimen3\font=0.2em% interword stretch
  \fontdimen4\font=0.1em% interword shrink
  \fontdimen7\font=0.1em% extra space
  \hyphenchar\font=`\-% allowing hyphenation
}


% cf. http://tex.stackexchange.com/questions/13423/how-to-change-the-color-of-href-links-for-real
\hypersetup{colorlinks,linkcolor=,urlcolor=blue}

% For the code items that we use more than once, put the href here.
\newcommand\GSObject{\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html}{\texttt{GSObject}}}
\newcommand\ChromaticObject{\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1chromatic_1_1_chromatic_object.html}{\texttt{ChromaticObject}}}
\newcommand\drawImage{\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html\#a67c2e0b2207854148cd060957808076c}{\texttt{drawImage}}}
\newcommand\Shear{\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1shear_1_1_shear.html}{\texttt{Shear}}}
\newcommand\Bandpass{\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1bandpass_1_1_bandpass.html}{\texttt{Bandpass}}}
\newcommand\SED{\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1sed_1_1_s_e_d.html}{\texttt{SED}}}
\newcommand\Image{\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1image_1_1_image.html}{\texttt{Image}}}
\newcommand\Add{\href{http://galsim-developers.github.io/GalSim/namespacegalsim_1_1compound.html\#ad3f305087db1b740376666d9c022d94e}{\texttt{Add}}}
\newcommand\Convolve{\href{http://galsim-developers.github.io/GalSim/namespacegalsim_1_1compound.html\#a17ccb8acb75a4eb6e35e791e4177957b}{\texttt{Convolve}}}

% Make the TOC take up a bit less space than the default (approx double spacing)
\setlength\cftparskip{0pt}

%=====================================================================
% FRONT MATTER
%=====================================================================

\slugcomment{\today}

%=====================================================================
% BEGIN DOCUMENT
%=====================================================================

\begin{document}

\setlength{\parskip}{2.0ex plus 0.5ex minus 0.5ex}
\setlength{\parindent}{0cm}

\title{GalSim Quick Reference}

\tableofcontents

\newpage

\section{Overview}

%\emph{BARNEY TODO: Tidy this whole thing up, make it look a lot less ugly,
%maybe use an entirely different document class.}

The GalSim package provides a number of Python classes and methods for
simulating astronomical images.  We assume GalSim is installed; see the
\href{https://github.com/GalSim-developers/GalSim/wiki}{GalSim Wiki}\footnote{
Note: links to various web pages are colored blue in this document to help you find more
information.}
or the file \texttt{INSTALL.md} in the base directory
for instructions.  The package is imported into Python with

\texttt{>>> import galsim}

and the typical work flow, as demonstrated in the example scripts in the {\tt
examples/} directory (all paths given relative to
the GalSim base directory from now on), will normally
be something like the following:

\begin{itemize}

\item[$\circ$]
  Construct a representation of your desired astronomical object
  as an instance of either the \GSObject\ or \ChromaticObject\ class, which represent (possibly
  wavelength-dependent) surface brightness profiles (of galaxies or PSFs).  Multiple components
  can be
  combined using the special \Add\ and \Convolve\ functions --- see Section~\ref{sect:gsobjects}.
\item[$\circ$]
  Apply transformations such as shears, shifts, rotation, or magnification
  using the methods of the \GSObject\ or \ChromaticObject\ --- see
  Sections~\ref{sect:gsobjectmethods}~\&~\ref{sect:chromaticity}.
\item[$\circ$]
  Draw the object into a GalSim \Image, representing a postage
  stamp image of your astronomical object.  This can be done using the
  \texttt{obj.}\drawImage\texttt{(\dots)}
  method carried by all \texttt{GSObject}s and
  \texttt{ChromaticObject}s for rendering images --- see
  Sections~\ref{sect:gsobjectmethods}~\&~\ref{sect:image}.
\item[$\circ$]
  Add noise to the \Image\ using one of the GalSim
  random deviate classes --- see Section~\ref{sect:random}.
\item[$\circ$]
  Add the postage stamp \Image\ to a subsection of a larger
  \Image\ instance --- see Section~\ref{sect:imagemethods}.
\item[$\circ$]
  Save the \Image(s) to file in FITS (Flexible Image Transport
  System) format --- see Sections~\ref{sect:imagemethods}~\&~\ref{sect:multifits}.
\end{itemize}

There are many examples of this workflow in the directory {\tt
 examples/}, showing most of the GalSim library in action, in
the scripts named \texttt{demo1.py} -- \texttt{demo13.py}. An online
\href{https://github.com/GalSim-developers/GalSim/wiki/Tutorials}{tutorial guide} outlines the
capabilities that are demonstrated in the demos.   This
document provides a brief, reference description of the GalSim classes
and methods which can be used in these workflows.

Where possible in the following Sections this document has been hyperlinked to the online
GalSim documentation generated by \emph{doxygen}, where a more detailed
description can be found.  We also suggest accessing the full docstrings for \emph{all} the
classes and functions described below in Python itself, e.g.\ by typing

\texttt{>>> help(galsim.<ObjectName>)}

within the Python interpreter.  If using the \emph{ipython} package,
which is recommended, instead simply type

\texttt{In [1]: galsim.<ObjectName>?}

and be sure to use the excellent tab-completion feature to explore the many
methods and attributes of the GalSim classes.

%\newpage

%\section{GSObject classes and methods}
\section{GSObjects}\label{sect:gsobjects}

\subsection{GSObject classes and when to use them}\label{sect:gsobjectclasses}
GalSim has many classes that represent various types of surface brightness profiles.
These are all subclasses of the \GSObject\ base class, which encapsulates
much of the functionality that is common to all such profiles in GalSim.
All but the last two classes listed below are
`simple' \texttt{GSObject}s that can be initialized by providing
values for their required and optional parameters.  The last two are
`compound' classes used to represent combinations of
\texttt{GSObject}s.

They are summarized in the following hyperlinked list, in which we also give
the required parameters for initializing each class in parentheses
after the class name.  For more information and initialization details for each \texttt{GSObject},
the Python docstring for each class is available within the Python interpreter, for example for
\texttt{Sersic} the documentation would be accessed using

\texttt{>>> help(galsim.Sersic)}

Alternatively follow the hyperlinks on
the class names listed below to view the documentation based
on the Python docstrings.

In cases where multiple options for specifying the object \emph{\texttt{size}}
exist we list these in the object description. We also show some of the optional
parameters available for use (e.g.\ total \texttt{flux}) along with default values:
\begin{itemize}
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_gaussian.html}{\texttt{Gaussian}}\texttt{(\emph{size}, flux=1.)}
    \newline
    A circular 2D Gaussian surface brightness profile. Requires one of the
    following \emph{\texttt{size}} parameters: \texttt{sigma}, \texttt{fwhm}, or \texttt{half\_light\_radius}.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_moffat.html}{\texttt{Moffat}}\texttt{(beta, \emph{size}, flux=1.)}
    \newline
    A Moffat profile with slope parameter \texttt{beta}, used to approximate ground-based
    telescope PSFs. Requires one of the
    following \emph{\texttt{size}} parameters: \texttt{scale\_radius},
    \texttt{fwhm}, or \texttt{half\_light\_radius}.  For information
    about other optional parameters, see the documentation for this object.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_airy.html}{\texttt{Airy}}\texttt{(lam\_over\_diam, obscuration=0., flux=1.)}
    \newline
    An Airy PSF for ideal diffraction
    through a circular aperture, parametrized by the wavelength-aperture
    diameter ratio \texttt{lam\_over\_diam}, with optional
    \texttt{obscuration}.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_kolmogorov.html}{\texttt{Kolmogorov}}\texttt{(\emph{size}, flux=1.)}
    \newline
    A Kolmogorov PSF for long-exposure
    images through a turbulent atmosphere. Requires one of the
    following \emph{\texttt{size}} parameters: \texttt{lam\_over\_r0}, \texttt{fwhm}, or
    \texttt{half\_light\_radius}.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1phase__psf_1_1_optical_p_s_f.html}{\texttt{OpticalPSF}}\texttt{(lam\_over\_diam, flux=1.)}
    \newline
    A simple model for non-ideal
    (aberrated) propagation through circular/square apertures, parametrized by the wavelength-
    aperture dimension ratio \texttt{lam\_over\_diam}, with
    optional \texttt{obscuration}.  For information
    about other optional parameters, see the documentation for this object.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1interpolatedimage_1_1_interpolated_image.html}{\texttt{InterpolatedImage}}\texttt{(image, \dots)}
    \newline
    A surface brightness profile for which we have an \texttt{Image} representation,
    which is interpolated appropriately to locations other than the pixel centers.
    For information about other optional parameters, see the documentation for this object.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_pixel.html}{\texttt{Pixel}}\texttt{(scale, flux=1.)}
    \newline
    A square tophat profile, used for representing pixels with pixel scale \texttt{scale}.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_box.html}{\texttt{Box}}\texttt{(width, height, flux=1.)}
    \newline
    An arbitrary rectangular box profile.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_top_hat.html}{\texttt{TopHat}}\texttt{(radius, flux=1.)}
    \newline
    A circular tophat profile.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_sersic.html}{\texttt{Sersic}}\texttt{(n, half\_light\_radius, flux=1.)}
    \newline
    A profile form the S\'{e}rsic family of galaxy light
    profiles, parametrized by an index \texttt{n} and \texttt{half\_light\_radius}.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_exponential.html}{\texttt{Exponential}}\texttt{(\emph{size}, flux=1.)}
    \newline
    An Exponential galaxy disc profile, a S\'{e}rsic
    with index \texttt{n=1}.  Requires one of the
    following \texttt{\emph{size}} parameters: \texttt{scale\_radius} or \texttt{half\_light\_radius}.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1inclinedexponential_1_1_inclined_exponential.html}{\texttt{InclinedExponential}}\texttt{(inclination, scale\_radius, scale\_height=0.1*scale\_radius, flux=1.)}
    \newline
    An Inclined Exponential galaxy disc profile. Requires the
    following parameters: \texttt{inclination} and \texttt{scale\_radius}.
    \texttt{scale\_height} can optionally provided; if not, it will default to 0.1*\texttt{scale\_radius}.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1inclinedsersic_1_1_inclined_sersic.html}{\texttt{InclinedSersic}}\texttt{(n, inclination, scale\_radius, scale\_height=0.1*scale\_radius, trunc=0., flux=1.)}
    \newline
    An Inclined Sersic galaxy disc profile, and a generalization of the InclinedExponential profile. Requires the
    following parameters: \texttt{n}, \texttt{inclination}, and \texttt{scale\_radius} or \texttt{half\_light\_radius}.
    \texttt{scale\_height} can optionally provided; if not, it will default to 0.1*\texttt{scale\_radius}. Allows a truncation radius
    \texttt{trunc} for the disk.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_de_vaucouleurs.html}{\texttt{DeVaucouleurs}}\texttt{(half\_light\_radius, flux=1.)}
    \newline
    A De Vaucouleurs galaxy bulge profile, a S\'{e}rsic
    with index \texttt{n=4} and input \texttt{half\_light\_radius}.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_spergel.html}{\texttt{Spergel}}\texttt{(nu, \emph{size}, flux=1.)}
    \newline
    A class describing a Spergel (2010) profile.   Requires one of the
    following \texttt{\emph{size}} parameters: \texttt{half\_light\_radius} or \texttt{scale\_radius}.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_delta_function.html}{\texttt{DeltaFunction}}\texttt{(flux=1.)}
  \newline
  A class for describing point sources.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1compound_1_1_random_walk.html}{\texttt{RandomWalk}}\texttt{(npoints, half\_light\_radius, flux=1., \dots)}
  \newline
  A class for generating a set of point sources distributed using a random walk, for representing
  irregular galaxies or knots of star formation on a disk.  The arguments describe how many point
  sources to distribute and within what spatial extent.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1real_1_1_real_galaxy.html}{\texttt{RealGalaxy}}\texttt{(real\_galaxy\_catalog, \dots)}
    \newline
    A galaxy model taken from an image of a real galaxy and includes
    a correction for the original PSF.   Use of this class requires the
    download of external data.  \texttt{RealGalaxy} objects can be directly instantiated based on a catalog that
    is input via the
    \texttt{real\_galaxy\_catalog} parameter (an instance of the
    \href{http://galsim-developers.github.io/GalSim/classgalsim_1_1real_1_1_real_galaxy_catalog.html}{\texttt{RealGalaxyCatalog}}
    class), or using the \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1scene_1_1_c_o_s_m_o_s_catalog.html}{COSMOSCatalog}} class.

    An example catalog of 100 real galaxies is in the repository itself; a set of real
    galaxy images, with original PSFs, can be downloaded following instructions on the
    \emph{RealGalaxy Data Download Page} on the
    \href{https://github.com/GalSim-developers/GalSim/wiki/RealGalaxy\%20Data}{GalSim Wiki}, or
    using an executable \texttt{galsim\_download\_cosmos} that is distributed with GalSim. For information
    about  optional parameters, see the documentation for this object.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1real_1_1_chromatic_real_galaxy.html}{\texttt{ChromaticRealGalaxy}}\texttt{(real\_galaxy\_catalogs, \dots)}
    \newline
    A galaxy model taken from multi-band images of real galaxies, including 
    a correction for the original PSFs.   Use of this class requires the
    download of external data. 
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1compound_1_1_sum.html}{\texttt{Sum}}\texttt{( [list of objects] )}
    \newline
    A {compound} object representing the sum of multiple \texttt{GSObject}s.
\item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1compound_1_1_convolution.html}{\texttt{Convolution}}\texttt{( [list of objects] )}
    \newline
    A compound object representing the convolution of multiple \texttt{GSObject}s.
\end{itemize}

Note that the last two objects, \texttt{Sum} and \texttt{Convolution}, are usually created by
invoking the \Add\ and \Convolve\ functions.  These functions will
automatically create \texttt{ChromaticSum} and \texttt{ChromaticConvolution} objects instead if
any of their arguments are \texttt{ChromaticObject}s instead of
\texttt{GSObects} (see Section~\ref{sect:chromaticity}).

Also note that all of the \texttt{GSObject}s except for \texttt{RealGalaxy}, \texttt{Sum}, and
\texttt{Convolution} {\em require} the specification of one size
parameter.

\subsection{Atmosphere}
GalSim can also simulate PSFs generated by turbulent layers in the atmosphere over a wide field of
view.  The syntax for creating this type of \texttt{GSObject} is a little bit different than for
those above.  First, some number of \texttt{AtmosphericScreen}s should be assembled into a
\texttt{PhaseScreenList}:

\begin{verbatim}
>>> r0_500 = 0.2 # Fried parameter (at 500 nm) in meters
>>> screen_size = 100 # Size of atmospheric screen in meters.
>>> layer0 = galsim.AtmosphericScreen(screen_size=screen_size, r0_500=r0_500)
>>> layer1 = ...
>>> layer2 = ...
>>> psl = galsim.PhaseScreenList([layer0, layer1, layer2])
\end{verbatim}

Note that \texttt{AtmosphericScreen}s have parameters for altitude (which affects how PSFs at
different field angles are related) and wind speed (which lets the screens evolve in time over an
exposure), in addition to parameters like \texttt{r0\_500} that control the fixed pattern of
turbulence in a screen.

To make a PSF, a telescope aperture is also needed:

\begin{verbatim}
>>> diam = 4.0 # Meters
>>> obscuration = 0.5 # Linear fractional obscuration
>>> aper = galsim.Aperture(diam=diam, obscuration=obscuration)
\end{verbatim}

Then to make PSFs, use the \texttt{PhaseScreenList.makePSF} method, optionally specifying a field
angle (i.e., where on the focal plane to generate the PSF):

\begin{verbatim}
>>> exptime = 30.0 # Exposure time in seconds.
>>> lam = 700.0 # Wavelength in nanometers.
>>> psf0 = psl.makePSF(exptime=exptime, lam=lam, aper=aper)
>>> psf1 = psl.makePSF(exptime=exptime, lam=lam, aper=aper,
...                    theta_x=0.1*galsim.arcmin, theta_y=0.1*galsim.arcmin)
\end{verbatim}

Note that when working with multiple PSFs coming from the same atmosphere but at different field
angles, it can sometimes be faster to first create all of the PSF objects and then draw them, as
opposed to interleaving PSF creation and drawing to images.

Also note that for phase screen objects, which include atmospheric PSFs and optical PSFs,
drawing images using photon-shooting can be sped up considerably by using a geometric optics
approximation, which is enabled for non-optical PSFs.  To use a more precise but slower
calculation, set the \texttt{geometric\_shooting} keyword argument to \texttt{False} when 
creating these objects.

\subsection{Units}
The choice of units for the \textit{size} parameters is up to the user,
but it must be kept consistent between all \GSObject s.  These
units must also adopted when specifying the \Image\ pixel
\texttt{scale}, whether this is set via the \texttt{GSObject}
instance method \texttt{obj.}\drawImage\texttt{(\dots)}
(see Section~\ref{sect:gsobjectmethods}),
or when constructing the \texttt{Image} (see Section~\ref{sect:image}).

As an example, consider the
\texttt{lam\_over\_diam} parameter, which provides an angular scale for
the \texttt{Airy} via
the ratio $\lambda / D$ for light at wavelength $\lambda$ passing
through a telescope of diameter $D$. Putting both $\lambda$ and
$D$ in metres and taking the ratio gives \texttt{lam\_over\_diam} in
radians, but this is not a commonly used angular scale when describing
astronomical objects such as galaxies and stellar PSFs, nor is
it often used for image pixel scales.  If wishing to use arcsec, which
is more common in both cases, the user should multiply the result in
radians by the conversion factor
$648000 / \pi$.  In principle, however, any consistent
system of units could be used.  Users wishing to separately specify the values of $\lambda$ and $D$
with their natural units of nanometers and meters may do so using \texttt{lam} and \texttt{diam}; in
that case, the keyword \texttt{scale\_unit} can be used to define the system of units used for the
scales in images.

The units for the \textit{flux} of a \GSObject are nominally photons/s/cm$^2$, and the units for an
image are ADUs (analog-to-digital units).  Note, however, that the default exposure time, telescope
collecting area, and gain are 1 s, 1 cm$^2$, and 1 ADU/photon (we combine photon-to-electron and
electron-to-ADU efficiencies), respectively, so users who wish to ignore the intricacies of managing
exposure times, collecting areas, and gains can simply think of the flux of a \GSObject in either
ADUs or photons.

These details matter more when working with \texttt{ChromaticObject}s, where the flux normalization
is handled with an \texttt{SED} object.  In fact, there are two types of \texttt{ChromaticObject}s
to consider: 1) \texttt{ChromaticObject}s representing astronomical objects like stars and galaxies
have units (once integrated over angle on the sky) of photons/s/cm$^2$/nm, 2)
\texttt{ChromaticObject}s representing wavelength-dependent PSFs are, by contrast, dimensionless.
(Technically, this distinction exists for achromatic astronomical objects and PSFs too, but we
usually ignore it there.)


\subsection{Important GSObject methods}\label{sect:gsobjectmethods}
A number of methods are shared by all the \GSObject s of
Section~\ref{sect:gsobjects}.
In what follows, we assume that a
\texttt{GSObject} labelled \texttt{obj} has been instantiated using
one of the calls described in the documentation linked above.  For
example,

\texttt{>>> obj = galsim.Sersic(n=3.5, half\_light\_radius=1.743)}.

Once again, for more information regarding each \texttt{galsim.GSObject}~method,
the Python docstring is available

\texttt{>>> help(obj.<methodName>)}

within the Python interpreter.  Alternatively follow the hyperlinks on
the class names above to view the documentation based
on the Python docstrings.

Some of the most important and commonly-used methods (shown with parenthesis) or properties (shown
without parenthesis) for such an
instance are:
\begin{itemize}
  \item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html#a3428ec61c500c299eaf83185794d0fd1}{\texttt{centroid}}
    \newline
    The $(x, y)$ centroid of the \texttt{GSObject} as a
    \texttt{PositionD} (see Section~\ref{sect:bounds}).
  \item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html#a5cf1843da478c2369a35cfbfdbccaa96}{\texttt{flux}}
    \newline
    The flux of the \texttt{GSObject}.
  \item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html#a39b00698a20025ead0678dc1bd847853}{\texttt{withScaledFlux}}\texttt{(flux\_ratio)}
    \newline
    Return a version of the \texttt{GSObject} with the flux scaled by \texttt{flux\_ratio}.
  \item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html#abc8d45679dfc86f63e46de5524639bb3}{\texttt{withFlux}}\texttt{(flux)}
    \newline
    Return a version of the \texttt{GSObject} with the flux set to \texttt{flux}.
  \item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html#aa26483093b11e5a0264ee3e0f3ad5acf}{\texttt{dilate}}\texttt{(scale)}
    \newline
    Return a version of this \texttt{GSObject} with the linear size dilated by a
    factor \texttt{scale}, conserving flux.
  \item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html#a3d40a46404ea7674af47459c975e333b}{\texttt{magnify}}\texttt{(mu)}
    \newline
    Return a version of this \texttt{GSObject} with the area magnified by a
    factor \texttt{mu}, conserving surface brightness.
  \item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html#a93a9c46634d62f37ff5cb7358ce73a85}{\texttt{shear}}\texttt{(\dots)}
    \newline
    Return a version of this \texttt{GSObject} that has been sheared by some amount.
    This method can handle a number of different
    input conventions for the shear (see also \Shear;
    Section~\ref{sect:shears}).  Commonly-used input conventions
    (supplied as keyword arguments, default values zero):
    \begin{itemize}
    \item \texttt{obj.shear(g1=g1, g2=g2)} \\
      Apply the first (\texttt{g1}) and second (\texttt{g2}) component
      of a shear defined so that $|g| = (a - b) / (a + b)$ where $a$ and
      $b$ are the semi-major and semi-minor axes of an ellipse.
    \item \texttt{obj.shear(e1=e1, e2=e2)} \\
      Apply the first (\texttt{e1}) and second (\texttt{e2}) component
      of a shear defined so that $|e| = (a^2 - b^2) / (a^2 + b^2)$ where $a$ and
      $b$ are the semi-major and semi-minor axes of an ellipse.
    \item \texttt{obj.shear(g=g, beta=beta)} \\
      Apply magnitude (\texttt{g}) and polar angle (\texttt{beta}) of a
      shear defined using the $|g|$ definition above.
    \item \texttt{obj.shear(e=e, beta=beta)} \\
      Apply magnitude (\texttt{e}) and polar angle (\texttt{beta}) of a
      shear defined using the $|e|$ definition above.
    \end{itemize}
  \item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html#a6154d3b762748b3441dd547d41593cc4}{\texttt{rotate}}\texttt{(theta)}
    \newline
    Return a version of the \texttt{GSObject} that has been rotated by an angle \texttt{theta}
    (positive direction anti-clockwise), where \texttt{theta} is an
    \texttt{Angle} instance (see Section~\ref{sect:angles}).
  \item[$\circ$]
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1gsobject_1_1_g_s_object.html#a41314ad780e3f646f2194bf372465bfa}{\texttt{shift}}\texttt{(dx, dy)}
    \newline
    Return a version of the \texttt{GSObject} with its centroid position shifted by $(dx, dy)$.
  \item[$\circ$]
  \texttt{image = obj.}\drawImage\texttt{(image=None, scale=None, wcs=None, method='auto', \\
  \phantom{image = obj.drawImage(}add\_to\_image=False, \dots)}
    \newline
    Draw and return an \Image\ (see Section \ref{sect:image}) of the \texttt{GSObject}.
    Some information about important optional parameters (see the
    linked Python docstrings for more detail), along with default values:
    \begin{itemize}
    \item \texttt{image} (default = \texttt{None}) \newline
      If supplied, the drawing will be done into a user-supplied
      \texttt{Image} instance \texttt{image}.  If not supplied
      (i.e. \texttt{image = None}), an
      automatically-sized \texttt{Image} instance will be returned.
    \item \texttt{scale} (default = \texttt{None}) \newline
      The optional image pixel \texttt{scale}, which if provided
      should use the same units as used for the \texttt{GSObject} size
      parameters.
    \item \texttt{wcs} (default = \texttt{None}) \newline
      The \texttt{wcs} may optionally be provided in lieu of a simple pixel scale,
      in which case this would specify the conversion between image
      coordinates and world (aka sky) coordinates.  The \texttt{GSObject}
      is taken to be defined in world coordinates and this function tells
      GalSim how to convert to image coordinates when it draws the profile.
      If neither \texttt{scale} nor \texttt{wcs} are provided here, then GalSim will
      use the \texttt{wcs} attribute of the \texttt{image} if available.
      Otherwise, it will use the Nyquist scale given the
      maximum modeled frequency in the \texttt{GSObject}.
    \item \texttt{method} (default = \texttt{'auto'})
      \begin{itemize}
        \item \texttt{'auto'} chooses either \texttt{'fft'} or \texttt{'real\_space'}
          appropriately based on the kind of profile being drawn.
        \item \texttt{'fft'} renders the image using a discrete Fourier transform to convolve by the
          pixel response.
        \item \texttt{'real\_space'} uses direct integration to integrate the flux over the pixels
          if possible.  (It defaults to \texttt{'fft'} when such a procedure is impossible or
          impractical.)
        \item \texttt{'phot'} renders the image by shooting a finite number of photons.
          The resulting rendering therefore contains stochastic noise, but uses few approximations.
          Note however, that you cannot use \texttt{'phot'} with a \texttt{RealGalaxy} instance.
          This \texttt{method} has a few additional optional parmaeters; see below.
        \item \texttt{'no\_pixel'} does not integrate over the pixel response, but rather samples
          the profile directly at the pixel centers and multiplies by the pixel area.  This is
          the appropriate choice if your PSF already includes the convolution by the pixel response,
          e.g. if it comes from an image of a star observed on the same camera.
        \item \texttt{'sb'} is simlar to \texttt{'no\_pixel'} except that it does not scale the
          values by the pixel area.  So the drawn values will be direct samples of the surface
          brightness at each location.
      \end{itemize}
    \item \texttt{add\_to\_image} (default = \texttt{False}) \newline
      Whether to add flux to a supplied \texttt{image} rather than clear out
      anything in the image before drawing.
  \end{itemize}
  If \texttt{method = 'phot'}, there are a number of additional optional parameters. Important
  examples worthy of mention are:
  \begin{itemize}
    \item \texttt{n\_photons} (default = \texttt{0}) \newline If provided,
      the number of photons to use.  If not provided, use as many photons
      as necessary to end up with an image with the correct poisson shot
      noise for the object's \texttt{flux}.  (Normally, this means use \texttt{n\_photons=flux},
      since \texttt{flux} is taken to be in units of photons, but there are exceptions to this.)
    \item \texttt{max\_extra\_noise} (default = \texttt{0.}) \newline If
      provided, the allowed extra noise in each pixel.  This is only
      relevant if \texttt{n\_photons = 0}, so the number of photons is
      being automatically calculated.  In that case, if the image noise is
      dominated by the sky background, you can get away with using fewer
      shot photons than the full \texttt{n\_photons = flux}.  Essentially
      each shot photon can have a $\texttt{flux} > 1$, which increases the
      noise in each pixel.  The \texttt{max\_extra\_noise} parameter
      specifies how much extra noise per pixel is allowed because of this
      approximation.
    \item \texttt{poisson\_flux} (default = \texttt{True}) \newline
      Whether to allow total object flux scaling to vary according to
      Poisson statistics for \texttt{n\_photons} samples.
  \end{itemize}
  The \drawImage\ method has a number of additional optional
  parameters.  Please see the linked Python docstrings for more
  details.
\end{itemize}

Finally, you may see by exploring the docstrings that many of the \texttt{GSObject}
instances also have their own specialized methods, often for
retrieving parameter values. Examples are
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_gaussian.html#a418f2826a7b8934cfedc181de23ce826}{\texttt{getSigma}}\texttt{()}
for the \texttt{Gaussian}, or
  \texttt{obj.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1base_1_1_sersic.html#ad6ca39293c6b478fc052d07ea51d086f}{\texttt{getHalfLightRadius}}\texttt{()}
for many of the \texttt{GSObject}s.

\section{Chromaticity}\label{sect:chromaticity}

Wavelength-dependent surface brightness profiles are represented as
\texttt{galsim.}\ChromaticObject\ instances in GalSim.
These objects generally require an \texttt{galsim.SED} to be created,
and always require a \texttt{galsim.Bandpass} object in order to draw.
Thus we will go over SEDs and Bandpasses first.

\subsection{Bandpasses}

The \texttt{galsim.}\Bandpass\ class represents a spectral throughput function, which could be an
entire imaging system throughput response function (reflection off of mirrors, transmission through
filters, lenses and the atmosphere, quantum efficiency of detectors), or individual pieces thereof.
\texttt{Bandpass}es, together with spectral energy distributions (SEDs; below) are necessary to
compute the relative contribution of each wavelength of a \texttt{ChromaticObject} to a drawn image.

\Bandpass\ instances may be initialized in several ways:
\begin{itemize}
  \item[$\circ$]
  \texttt{galsim.Bandpass(filename, wave\_type, \dots)}
    \newline
    where \texttt{filename} points to a
    text file with two columns, the first for wavelength and the second for dimensionless
    throughput.  \texttt{wave\_type} is used to tell GalSim whether the wavelengths in that file are
    in units of nanometers or Angstroms.
  \item[$\circ$]
  \texttt{galsim.Bandpass(function, wave\_type, blue\_limit, red\_limit, \dots)}
    \newline
    where \texttt{function} is a python function that accepts wavelength and returns
    dimensionless throughput, and \texttt{wave\_type} is as above.
    The keywords \texttt{red\_limit} and \texttt{blue\_limit} are required in
    this case to specify the integration limits of the bandpass.
\end{itemize}

For \texttt{Bandpass} instances initialized from a file, the following two methods can be used to
reduce the number of samples used for integrations (and hence reduce the time it takes to draw
a \texttt{ChromaticObject}).
\begin{itemize}
  \item[$\circ$]
  \texttt{bandpass.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1bandpass_1_1_bandpass.html\#a230865a1e29ed8a95ea4b2c7d66a08a1}{truncate}(blue\_limit,
    red\_limit, relative\_throughput, \dots)}
    \newline
    Return a new bandpass truncated to only include wavelengths between \texttt{blue\_limit} and
    \texttt{red\_limit}, or truncated based on the supplied \texttt{relative\_throughput} level.
  \item[$\circ$]
  \texttt{bandpass.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1bandpass_1_1_bandpass.html\#a20a7b1813506e7441e03ef097f0d5bf1}{thin}(rel\_err,\dots)}
    \newline
   Return a thinner version of the bandpass by removing sample values (locations where
   $F(\lambda)$ is defined) while retaining the
   accuracy of the integral over the bandpass to the stated relative error \texttt{rel\_err}.  Other
   aspects of the behavior of this routine are set via additional keyword arguments.
\end{itemize}

Finally, note that \texttt{Bandpass} instances may be multiplied
together and are callable, returning dimensionless throughput as a
function of wavelength in nanometers.

\subsection{SEDs}
Spectral energy distributions, respresented by the \SED\ class,
may be constructed in several ways, similarly to bandpasses:
\begin{itemize}
  \item[$\circ$]
  \texttt{galsim.SED(filename, wave\_type, flux\_type, \dots)}
    \newline
    where \texttt{filename} points to a
    text file with two columns, the first for wavelength in units given by \texttt{wave\_type} and the second for flux
    density in units given by \texttt{flux\_type}.
  \item[$\circ$]
  \texttt{galsim.SED(function, wave\_type, flux\_type, \dots)}
    \newline
    where \texttt{function} is a python
    function that accepts wavelength in units given by \texttt{wave\_type} and returns flux density in units given by \texttt{flux\_type}.
\end{itemize}

SEDs can be created using the \texttt{astropy.units} module to specify \texttt{wave\_type} and \texttt{flux\_type}.  For example:

\begin{verbatim}
>>> from astropy import units as u
>>> sed = galsim.SED(filename, wave_type=u.nm, flux_type=u.erg/(u.s*u.cm**2*u.nm))
\end{verbatim}

Important methods for \SED\ objects include:
\begin{itemize}
  \item[$\circ$]
  \texttt{sed.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1sed_1_1_s_e_d.html\#abd38352d0cd9327ba255b8f327562992}{withFluxDensity}(target\_flux\_density,
    wavelength)}
      \newline
      Return a new \texttt{SED} with the same functional shape,
      but with the flux
      density (in units of ergs/nm) at the reference
      wavelength \texttt{wavelength} set to
      \texttt{target\_flux\_density}.  Note that \texttt{SED} objects are
      immutable, so the original \texttt{SED} is unchanged.
  \item[$\circ$]
  \texttt{sed.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1sed_1_1_s_e_d.html\#ab20b0c861f5b6a6604fe838b83a4d6cc}{calculateFlux}(bandpass)}
    \newline
    Calculate and return the flux transmitted through a
    \texttt{bandpass} in photons.
  \item[$\circ$]
  \texttt{sed.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1sed_1_1_s_e_d.html\#a33613fdc3b0f99534971e9651ea2e659}{withFlux}(target\_flux, bandpass)}
    \newline
    Return a new \texttt{SED}
    for which the flux transmitted through the input \texttt{bandpass} is \texttt{target\_flux}.
  \item[$\circ$]
  \texttt{sed.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1sed_1_1_s_e_d.html\#a9d49d109ff539f61ab022e1be6391b12}{atRedshift}(z)}
    \newline
    Return a new \texttt{SED} instance with wavelength shifted be at redshift $z$.
    Note that \texttt{SED} instances remember their redshifts (except when created as sums and
    differences of
    other SEDs), so applying this method a second twice with the same argument $z$ is equivalent
    to applying it just once.
\end{itemize}

GalSim uses SED instances both to represent spectral density and dimensionless wavelength-dependent
normalization.  (The former for stars and galaxies, the latter for chromatic PSFs.)  \texttt{SED}
instances can be added together, multiplied by scalars or functions (of wavelength in nanometers),
and are callable, returning either flux density in photons/s/cm$^2$/nm or dimensionless
normalization as appropriate.  Some operations are restricted depending on \texttt{SED.flux\_type}.
For instance, the product of two \texttt{SED}s with units photons/s/cm$^2$/nm is prohibited since
the resulting object would not have the dimensions of an \texttt{SED}.

\subsection{ChromaticObjects}

Chromatic surface brightness profiles are generally constructed by modifying an existing
\GSObject.  The simplest possible \ChromaticObject\ can be formed by passing a
\texttt{GSObject} to the \texttt{ChromaticObject} constructor:

\texttt{>>> obj = galsim.Gaussian(fwhm=1.0)}\newline
\texttt{>>> chromatic\_obj = galsim.ChromaticObject(obj)}

At this stage, \texttt{chromatic\_obj} represents the same profile as \texttt{obj}, but
now has access to \ChromaticObject\ methods.

The simplest way to construct a non-trivial chromatic object is to multiply a \texttt{GSObject} by
an \texttt{SED}.  This creates a separable wavelength-dependent surface brightness profile
$\mathrm{I}(x, y, \lambda) = \mathrm{I}_0(x, y) \mathrm{f}(\lambda)$:

\texttt{>>> chromatic\_obj = obj * sed}

\texttt{ChromaticObject}s may be combined and transformed similarly to
\texttt{GSObjects}, using the functions and methods \texttt{Add}, \texttt{Convolve}, \texttt{withScaledFlux}, \texttt{dilate}, \texttt{magnify}, \texttt{shear}, \texttt{rotate}, and \texttt{shift}.

The transformation methods of \texttt{ChromaticObject}s, like \href{http://galsim-developers.github.io/GalSim/classgalsim_1_1chromatic_1_1_chromatic_object.html#adb05a4f0dadc3c7cbc361ec97984e6f1}{\texttt{dilate}} and \href{http://galsim-developers.github.io/GalSim/classgalsim_1_1chromatic_1_1_chromatic_object.html#ab266ee1207d60ba7a9fb6b32a4ef6ab2}{\texttt{shift}},
can also accept as an argument a function of wavelength (in nanometers)
that returns a wavelength-dependent dilation, shift, etc.  These can be used to implement
chromatic PSFs.  For example, a diffraction limited PSF might look
like:

\texttt{>>> psf500 = galsim.Airy(lam\_over\_diam=2.0)}\newline
\texttt{>>> chromatic\_psf = ChromaticObject(psf500).dilate(lambda w:(w/500)**(1.0))}

The \href{http://galsim-developers.github.io/GalSim/classgalsim_1_1chromatic_1_1_chromatic_object.html#a4228098295ee04e4f491567a9ce3b28f}{\texttt{drawImage}} method of a \texttt{ChromaticObject} is similar to the \drawImage\ method of a \texttt{GSObject},
except that it requires a \texttt{Bandpass} object as its first
argument.  Note that only \texttt{ChromaticObject}s with \texttt{SED}s having units of photons/s/cm$^2$/nm can be drawn.

\texttt{>>> gband = galsim.Bandpass(lambda w:1.0, wave\_type='nm', blue\_limit=410, red\_limit=550)} \newline
\texttt{>>> image = chromatic\_obj.drawImage(gband)}

GalSim comes with built-in support for ground-based PSFs affected by differential chromatic
refraction and Kolmogorov chromatic seeing ($\mathrm{FWHM} \propto \lambda^{-0.2}$) through the
following class:
\begin{itemize}
  \item[$\circ$]
  \texttt{\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1chromatic_1_1_chromatic_atmosphere.html}{ChromaticAtmosphere}\texttt{(base\_obj, base\_wavelength, \dots)}}
    \newline
    where \texttt{base\_obj} is the fiducial PSF at wavelength \texttt{base\_wavelength}.
    There are a number of options for specifying details like the position of the object with
    respect to zenith and the physical properties of the atmosphere.
\end{itemize}

There are also classes for representing chromatic optical PSFs:
\begin{itemize}
   \item[$\circ$]
   \texttt{\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1chromatic_1_1_chromatic_airy.html}{ChromaticAiry}\texttt{(\dots)}}
    \newline
   for representing a chromatic Airy profile, where the user must specify either \texttt{lam} (the
   telescope diameter in meters) or \texttt{lam\_over\_diam} (the ratio of some fiducial wavelength
   to the diameter).
   \item[$\circ$]
   \texttt{\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1chromatic_1_1_chromatic_optical_p_s_f.html}{ChromaticOpticalPSF}\texttt{(\dots)}}
    \newline
   for representing a fully chromatic optical PSF, including chromatic aberrations.
\end{itemize}

For sufficiently complex chromatic objects, an optional optimization can be invoked to speed up the
image rendering process; for more information, view the docstring for the
\texttt{setupInterpolation} method associated with \texttt{ChromaticObject}s.

\section{Random deviates}\label{sect:random}
\subsection{Random deviate classes and when to use them}
Random deviates can be used to add a stochastic
component to the modeling of astronomical images, such as drawing
object parameters according to a given distribution or generating random
numbers to be added to image pixel values to model noise.

We now give a short summary of the 8 random deviates currently
implemented in GalSim.   The optional parameter \emph{\texttt{seed}}
listed below is used
to seed the pseudo-random number generator: it can
either be omitted (the random deviate seed will be set using the
current time), set to an integer seed, or used to pass another random
deviate (the new instance will then use and update the same underlying
generator as the input deviate).

The deviates, with a description of their distributions, parametrization and
default parameter values, are as follows:\footnote{
Note that, with the exception of \texttt{DistDeviate},
all the deviate classes are defined in the C++ layer, so the hyper-links
below link to that code, rather than the Python documentation.  The
syntax is not too different in Python, but unfortunately, the docstrings
are not currently linkable directly.
For more information, please refer to the full docstrings, accessible
via commands like \texttt{help(galsim.UniformDeviate)} in the Python interpreter.}

\begin{itemize}

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_uniform_deviate.html}{UniformDeviate}(\emph{seed})}
    \newline
    Uniform distribution in the interval $[0, 1)$.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_gaussian_deviate.html}{GaussianDeviate}(\emph{seed}, mean=0., sigma=1.)}
    \newline
    Gaussian distribution with \texttt{mean} and standard deviation \texttt{sigma}.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_binomial_deviate.html}{BinomialDeviate}(\emph{seed}, N=1, p=0.5)}
    \newline
    Binomial distribution for \texttt{N} trials each of probability \texttt{p}.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_poisson_deviate.html}{PoissonDeviate}(\emph{seed}, mean=1.)}
    \newline
    Poisson distribution with a single \texttt{mean} rate.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_weibull_deviate.html}{WeibullDeviate}(\emph{seed}, a=1., b=1.)}
    \newline
    Weibull distribution family (includes Rayleigh and Exponential) with shape parameters
    \texttt{a} and \texttt{b}.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_gamma_deviate.html}{GammaDeviate}(\emph{seed}, alpha=1., beta=1.)}
    \newline
    Gamma distribution with parameters \texttt{alpha} and \texttt{beta}.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_chi2_deviate.html}{Chi2Deviate}(\emph{seed}, n=1.)}
    \newline
    $\chi^2$ distribution with degrees-of-freedom parameter \texttt{n}.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1random_1_1_dist_deviate.html}{DistDeviate}(\emph{seed}, function, x\_min, x\_max)}
    \newline
    Use an arbitrary function for $P(x)$ from \texttt{x\_min} .. \texttt{x\_max}.

\end{itemize}

It is possible to specify the random seed so as to get fully
deterministic behavior of the noise when running a particular script.

\subsection{Important random deviate methods}\label{sect:randommethods}
We now illustrate the most commonly-used methods of the random
deviates, assuming that some random deviate instance \texttt{dev} has
been instantiated, for example by

\texttt{>>> dev = galsim.GaussianDeviate(sigma=3.9, mean=50.)}.

The most important and commonly-used method for such
instances is:
\begin{itemize}

  \item[$\circ$] \texttt{dev()}
    \newline
    Calling the deviate directly simply returns a single new random number drawn from the
    distribution
    represented by \texttt{dev}.  As an example:\newline \\
    \texttt{>>> dev = galsim.UniformDeviate(12345)}\\
    \texttt{>>> dev()} \\
    \texttt{0.9296160866506398} \\
    \texttt{>>> dev() }\\
    \texttt{0.8901547130662948}

\end{itemize}

\subsection{Noise models}\label{sect:noisemodels}

One common way to use the random deviates is as part of a noise model for adding
noise to an image.  These have their own separate hierarchy of classes

\begin{itemize}
  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_gaussian_noise.html}{GaussianNoise}(rng, sigma=1.)}
    \newline
    Every pixel gets Gaussian noise with rms \texttt{sigma}, using the
    random number generator given as \texttt{rng}, which may be any deviate instance.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_poisson_noise.html}{PoissonNoise}(rng, sky\_level=0.)}
    \newline
    Every pixel gets Poisson noise according to the flux in
    the image plus an option sky level, \texttt{sky\_level}, using the
    random number generator given as \texttt{rng}, which may be any deviate instance.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_deviate_noise.html}{DeviateNoise}(dev)}
    \newline
    The noise
    value for every pixel is drawn from the given Deviate instance
    \texttt{dev}.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_c_c_d_noise.html}{CCDNoise}(rng, sky\_level=0., gain=1.,
    read\_noise=0.)}
    \newline
    A combination of Poisson noise (with a
    gain value in electrons/ADU) and Gaussian read noise, using the
    random number generator given as \texttt{rng}, which may be any deviate instance.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1noise_1_1_variable_gaussian_noise.html}{VariableGaussianNoise}(rng, var\_image)}
    \newline
    Every pixel gets Gaussian noise with variance given by the \texttt{var\_image} parameter
    (an \Image\ instance), using the
    random number generator given as \texttt{rng}, which may be any deviate instance.
    The supplied \texttt{var\_image} must be the same size and shape as the \Image\
    onto which the noise is eventually added.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1correlatednoise_1_1_correlated_noise.html}{CorrelatedNoise}(image, rng, ...)}
    \newline
   The provided image should be a pure noise field (i.e. a blank area of sky with no detectable
    objects).  The correlated noise of this image will be computed, which can then be applied
    to any other image, laying down noise with the same correlations.  The provided
    random number generator, \texttt{rng}, which may be any deviate instance will be used
    as the basis of the required random numbers..

\end{itemize}

To apply noise to an \Image\ using these noise models, the command is simply:

\begin{itemize}

  \item[$\circ$]
  \texttt{image.\href{http://galsim-developers.github.io/GalSim/namespacegalsim_1_1noise.html\#aa45903c801b069774d5eafdbee54bda7}{addNoise}(noise)}
    \newline
    This adds stochastic noise, according to the noise model \texttt{noise},
    to each element of the data array in the
    \texttt{Image} instance \texttt{image}.

\end{itemize}

In addition, GalSim can remove some or all of the noise correlations in an image that has
a known correlated noise:

\begin{itemize}

  \item[$\circ$]
  \texttt{image.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1correlatednoise_1_1___base_correlated_noise.html\#af39b3141a36a515022acabae5c973817}{whitenNoise}(noise)}
    \newline
    This adds extra correlated noise
    to the image such that if the image initially has correlated noise given by \texttt{noise}
    (which should be a \texttt{CorrelatedNoise} object), then the image will end up with
    white noise.  It tries to add the minimum amount of extra noise possible to achieve this.

  \item[$\circ$]
  \texttt{image.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1correlatednoise_1_1___base_correlated_noise.html\#a8f4cb9995d9e097a35aaf87da1b72ec1}{symmetrizeNoise}(noise, order=4)}
    \newline
    This is similar to \texttt{whitenNoise},
    except that rather than making the resulting noise profile completely white, it just makes
    the final noise in the image have N-fold symmetry where N is given by \texttt{order}.
    This typically requires much less noise to be added than \texttt{whitenNoise}, and for
    many purposes this is sufficient to remove the adverse effects of correlated noise.

\end{itemize}

\section{Images}\label{sect:image}

\subsection{Image classes and when to use them}\label{sect:imageclasses}
The GalSim \Image\ class stores array data, along with the bounds
of the array, and a
function that converts between image coordinates and world coordinates
(also known as sky coordinates).  The most common World Coordinate System
(WCS) function that you will encounter is a simple scaling of the units
from pixels to arcsec.  This WCS can be specified simply by \texttt{im.scale},
as we have seen already.  More complicated WCS functions would need to
be referenced via \texttt{im.wcs}.
See the docstring for \href{http://galsim-developers.github.io/GalSim/classgalsim_1_1wcs_1_1_base_w_c_s.html}{\texttt{BaseWCS}}
for more details.

\Image\ instances can be operated upon to add stochastic noise
simulating real astronomical images (see Section~\ref{sect:random}),
and have methods for writing to FITS format output.

The most common way to initialize an
image is with two integer parameters \texttt{nx} and \texttt{ny},
giving the image extent in the $x$ and $y$ dimensions, respectively.
Example initialization is therefore:
\begin{itemize}
  \item[$\circ$] \texttt{galsim.Image(nx, ny)}
\end{itemize}
This would create an image with single precision (32 bit) floats for the data elements, which
is usually the most appropriate type for astronomical images.  However, you can specify
other types for the data using a suffix letter after \texttt{Image}:
\begin{itemize}
  \item[$\circ$] \texttt{galsim.ImageS(nx, ny)} {for 16 bit integers.}

  \item[$\circ$] \texttt{galsim.ImageI(nx, ny)} {for 32 bit integers.}

  \item[$\circ$] \texttt{galsim.ImageF(nx, ny)} {for single precision (32 bit) floats.}

  \item[$\circ$] \texttt{galsim.ImageD(nx, ny)} {for double precision (64 bit) floats.}
\end{itemize}
Other ways to construct an \Image\ can be found in the
docstrings, including via an input NumPy array.

To access the data as a NumPy array, simply use the \texttt{image.array}
attribute, where \texttt{image} is an instance of one of these
\texttt{Image} classes.  However, note that the individual elements in
the array attribute are accessed as \texttt{image.array[y,x]}, matching
the standard NumPy convention, while the \texttt{Image} class's own
accessors are all $(x,y)$ in ordering.

\subsection{Important Image methods and operations}\label{sect:imagemethods}
We now illustrate the most commonly-used methods of \Image\
class instances.  We will assume that some \texttt{Image} instance
\texttt{image} has been instantiated, for example by

\texttt{>>> image = galsim.Image(100, 100)}.

This \texttt{Image} instance is then ready to pass to a
\texttt{GSObject} for drawing.  The most important and commonly-used
methods for such an instance are:

\begin{itemize}

  \item[$\circ$]
  \texttt{image.bounds}
    \newline
    Get the bounding box of the data.

  \item[$\circ$]
  \texttt{image.wcs}
    \newline
    Get or set the WCS function to convert between
    image coordinates and world coordinates.

  \item[$\circ$]
  \texttt{image.scale}
    \newline
    Get or set the pixel
    scale \texttt{scale} for this image.  The getter only works if the WCS
    is really just a pixel scale.  The setter will make it a pixel scale.

  \item[$\circ$]
  \texttt{image.\href{http://galsim-developers.github.io/GalSim/namespacegalsim_1_1noise.html\#aa45903c801b069774d5eafdbee54bda7}{addNoise}(noise)}
    \newline
    This adds
    stochastic noise according to the given noise model, \texttt{noise}
    to each element of the data array in \texttt{image}.
    This is the method previously referenced in Section~\ref{sect:random}.

  \item[$\circ$]
  \texttt{image.\href{http://galsim-developers.github.io/GalSim/namespacegalsim_1_1fits.html\#a9f3f9dce30942b81d85d2f8928ece310}{write}(file\_name, \dots)}
    \newline
    Write the
    \texttt{image} to a FITS file, given by \texttt{file\_name}.
    There are other options for how to write this (such as writing to an HDUList
    rather than a file), so see the docstring for more details, including
    details about the optional parameters.
    In Section~\ref{sect:multifits} we discuss how to write to multi-extension FITS files.

\end{itemize}

\texttt{Image} instances are also returned when
accessing a sub-section of an existing \texttt{Image}.  For example

\texttt{>>> imsub = image.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1image_1_1_image.html\#a968b8dce7fb7155a09fe44c064a285aa}{subImage}(bounds)}

where \texttt{bounds} is a \texttt{BoundsI} instance (see Section
\ref{sect:bounds}) assigns \texttt{imsub} as an view into
the sub-region of \texttt{image} lying in the area represented by
\texttt{bounds}.  Equivalent syntax is also

\texttt{>>> imsub = image[bounds]}

It is also possible to change the values of a sub-region of an image
this way, for example

\texttt{>>> image[imsub.bounds] += imsub}

if wishing to add the contents of \texttt{imsub} to the area lying
within its bounds in \texttt{image}.  Note that here we have made use of
the \texttt{image.bounds} attribute carried by all of the \texttt{Image}
classes.

\section{Miscellaneous classes and functions}\label{sect:misc}

A summary of miscellaneous GalSim library objects, subcategorized into
broad themes.  As ever, docstrings for \emph{all} the classes and
functions below can be accessed via \texttt{help(galsim.<Name>)}
within the Python interpreter.

\subsection{Angles}\label{sect:angles}

\begin{itemize}

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_angle.html}{Angle}(value, angle\_unit)}
    \newline
    Class to represent angles (with multiple unit types),
    which can be initialized by multiplying a numerical
    value and an \texttt{AngleUnit} instance \texttt{angle\_unit} (see
    below).

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_angle_unit.html}{AngleUnit}}
    \newline
    There are five built-in \texttt{AngleUnit}s which are
    always available for use:
    \begin{itemize}
      \item \texttt{galsim.radians}
      \item \texttt{galsim.degrees}
      \item \texttt{galsim.hours}
      \item \texttt{galsim.arcmin}
      \item \texttt{galsim.arcsec}
    \end{itemize}
    Please see the Python docstrings for information about defining your
    own \texttt{AngleUnit}s.

\end{itemize}

\subsection{Bounds and Positions}\label{sect:bounds}

\begin{itemize}

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_bounds.html}{BoundsI}(\dots)}
    \newline
    \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_bounds.html}{BoundsD}(\dots)}
    \newline
    Classes to represent image boundaries as the vertices of a rectangle.

  \item[$\circ$]
  \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_position.html}{PositionI}(x, y)}
    \newline
    \texttt{galsim.\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1_position.html}{PositionD}(x, y)}
    \newline
    Classes to represent
    2D positions on the \texttt{x}-\texttt{y} plane, e.g., for describing object centroid
    positions.

For both bounds and positions, the \texttt{I} and \texttt{D} refer to
integer and double-precision floating point representations.

\end{itemize}

\subsection{Shears}\label{sect:shears}

\begin{itemize}

  \item[$\circ$]
  \texttt{galsim.}\Shear\texttt{(\dots)}
    \newline
    Class to represent shears in a variety of ways.  This class can be initialized using a
    variety of different parameter conventions (see
    the doc string for the complete list).  Commonly-used examples (supplied as
    keyword arguments, default values zero):
    \begin{itemize}
      \item \texttt{galsim.Shear(g1=g1, g2=g2)} \\
        set via the first (\texttt{g1}) and second (\texttt{g2}) component
        of a shear defined so that $|g| = (a - b) / (a + b)$ where $a$ and
        $b$ are the semi-major and semi-minor axes of an ellipse.
      \item \texttt{galsim.Shear(e1=e1, e2=e2)} \\
        set via the first (\texttt{e1}) and second (\texttt{e2}) component
        of a shear defined so that $|e| = (a^2 - b^2) / (a^2 + b^2)$ where $a$ and
        $b$ are the semi-major and semi-minor axes of an ellipse.
      \item \texttt{galsim.Shear(g=g, beta=beta)} \\
        set via magnitude (\texttt{g}) and polar angle (\texttt{beta}) of a
        shear defined according to the $|g|$ definition above.
      \item \texttt{galsim.Shear(e=e, beta=beta)} \\
        set via magnitude (\texttt{e}) and polar angle (\texttt{beta}) of a
        shear defined according to the $|e|$ definition above.
   \end{itemize}

\end{itemize}

\subsection{Lensing shear fields}\label{sect:lensing}

GalSim has functionality to simulate scientifically-motivated lensing
shear fields.  The two relevant classes for users are:

\begin{itemize}
  \item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1lensing__ps_1_1_power_spectrum.html}{\texttt{PowerSpectrum}}\texttt{(\dots)}
    \newline
    Represents a flat-sky shear power spectrum $P(k)$, where the $E$ and
    $B$-mode power spectra can be separately specified as
    \texttt{E\_power\_function} and \texttt{B\_power\_function}.  The
    \texttt{getShear(\dots)} method is used to generate a random realization of
    a shear field from a given \texttt{PowerSpectrum} object,
    and there are methods to get convergence or magnification as well.

  \item[$\circ$]
  \texttt{galsim.}\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1nfw__halo_1_1_n_f_w_halo.html}{\texttt{NFWHalo}}\texttt{(\dots)}
    \newline
    Represents a matter density profile corresponding to a projected,
    circularly-symmetric NFW profile such as might be used to simulate lensing
    by a galaxy cluster.  This class has two methods of interest for users,
    \texttt{getShear()} and \texttt{getConvergence()}, which can be used to get
    the shears and convergences at {\em any} (non-gridded) image-plane
    position.
\end{itemize}

These classes have additional requirements on the units used to specify
positions; see the documentation for these classes for more details.

The GalSim repository also contains a module with a
\href{http://galsim-developers.github.io/GalSim/classgalsim_1_1pse_1_1_power_spectrum_estimator.html}{\texttt{PowerSpectrumEstimator}} class that can be used to estimate shear power
spectra from gridded shear values.  See the linked documentation for more information.

\subsection{Additional FITS input/output tools}\label{sect:multifits}

For all of these functions, there are also options for reading/writing directly from/to
an HDUList rather than a file, so see the linked doc strings for more details.
Optional parameters control how to handle compression, although the default in all cases
is to try to use the correct compression scheme based on the file's extension.

\begin{itemize}

  \item[$\circ$]
  \texttt{image = galsim.fits.\href{http://galsim-developers.github.io/GalSim/namespacegalsim_1_1fits.html\#abbad6f82a80bc74fb22a752af1bbd8e9}{read}(file\_name, \dots)}
    \newline
    Returns an \Image\ instance \texttt{image} from a FITS file, \texttt{file\_name}.
    If the FITS file has a WCS defined in the header,
    then GalSim will attempt to read that WCS and store it as \texttt{image.wcs}.
  \item[$\circ$]
  \texttt{image\_list = galsim.fits.\href{http://galsim-developers.github.io/GalSim/namespacegalsim_1_1fits.html\#ae7aacb9f44faf9e487e83e12b9dd9067}{readMulti}(file\_name, \dots)}
    \newline
    Returns a Python \texttt{list} of \Image\ instances (\texttt{image\_list}) from a
    Multi-Extension FITS file, \texttt{file\_name}.
  \item[$\circ$]
  \texttt{galsim.fits.\href{http://galsim-developers.github.io/GalSim/namespacegalsim_1_1fits.html\#a17dbb70385408586795efade476cdc98}{writeMulti}(image\_list, file\_name, \dots)}
    \newline
    Write multiple \Image\ instances stored in a Python
    \texttt{list} (\texttt{image\_list}) to a Multi-Extension FITS file, \texttt{file\_name}.
  \item[$\circ$]
  \texttt{galsim.fits.\href{http://galsim-developers.github.io/GalSim/namespacegalsim_1_1fits.html\#aa4fbd5ed42ffecda339a409296f0f101}{writeCube}(image\_list, file\_name, \dots)}
    \newline
    Write multiple \Image\ instances stored in a Python
    \texttt{list} (\texttt{image\_list}) to a three-dimensional FITS datacube, \texttt{file\_name}.

\end{itemize}


\end{document}
