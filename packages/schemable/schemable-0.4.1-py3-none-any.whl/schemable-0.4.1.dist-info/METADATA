Metadata-Version: 2.1
Name: schemable
Version: 0.4.1
Summary: A schema loading and validation library
Home-page: https://github.com/dgilland/schemable
Author: Derrick Gilland
Author-email: dgilland@gmail.com
License: MIT License
Keywords: schemable
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Provides-Extra: dev
Provides-Extra: dev
Requires-Dist: coverage; extra == 'dev'
Requires-Dist: flake8; extra == 'dev'
Requires-Dist: pylint; extra == 'dev'
Requires-Dist: pytest; extra == 'dev'
Requires-Dist: pytest-cov; extra == 'dev'
Requires-Dist: Sphinx; extra == 'dev'
Requires-Dist: sphinx-rtd-theme; extra == 'dev'
Requires-Dist: tox; extra == 'dev'
Requires-Dist: twine; extra == 'dev'
Requires-Dist: wheel; extra == 'dev'

schemable
*********

|version| |travis| |coveralls| |license|


Schemable is a schema parsing and validation library that let's you define schemas simply using dictionaries, lists, types, and callables.


Links
=====

- Project: https://github.com/dgilland/schemable
- Documentation: https://schemable.readthedocs.io
- PyPI: https://pypi.python.org/pypi/schemable/
- TravisCI: https://travis-ci.org/dgilland/schemable


Features
========

- Simple schema definitions using ``dict``, ``list``, and ``type`` objects
- Complex schema definitions using ``Any``, ``All``, ``As``, and predicates
- Detailed validation error messages
- Partial data loading on validation failure
- Strict and non-strict parsing modes
- Python 3.4+


Quickstart
==========

Install using pip:


::

    pip install schemable


Define a schema using ``dict`` and ``list`` objects:

.. code-block:: python

    from schemable import Schema, All, Any, As, Optional, SchemaError

    user_schema = Schema({
        'name': str,
        'email': All(str, lambda email: len(email) > 3 and '@' in email),
        'active': bool,
        'settings': {
            Optional('theme'): str,
            Optional('language', default='en'): str,
            Optional('volume'): int,
            str: str
        },
        'aliases': [str],
        'phone': All(str,
                     As(lambda phone: ''.join(filter(str.isdigit, phone))),
                     lambda phone: 10 <= len(phone) <= 15),
        'addresses': [{
            'street_addr1': str,
            Optional('street_addr2', default=None): Any(str, None),
            'city': str,
            'state': str,
            'country': str,
            'zip_code': str
        }]
    })


Then validate and load by passing data to ``user_schema()``:


.. code-block:: python

    # Fail!
    result = user_schema({
        'name': 'Bob Smith',
        'email': 'bob.example.com',
        'active': 1,
        'settings': {
            'theme': False,
            'extra_setting1': 'val1',
            'extra_setting2': True
        },
        'phone': 1234567890,
        'addresses': [
            {'street_addr1': '123 Lane',
             'city': 'City',
             'state': 'ST',
             'country': 'US',
             'zip_code': 11000}
        ]
    })

    print(result)
    # SchemaResult(
    #     data={'name': 'Bob Smith',
    #           'settings': {'extra_setting1': 'val1',
    #                        'language': 'en'}
    #           'addresses': [{'street_addr1': '123 Lane',
    #                          'city': 'City',
    #                          'state': 'ST',
    #                          'country': 'US',
    #                          'street_addr2': None}]},
    #     errors={'email': "bad value: <lambda>('bob.example.com') should evaluate to True",
    #             'active': 'bad value: type error, expected bool but found int',
    #             'settings': {'theme': 'bad value: type error, expected str but found bool',
    #                          'extra_setting2': 'bad value: type error, expected str but found bool'},
    #             'phone': 'bad value: type error, expected str but found int',
    #             'addresses': {0: {'zip_code': 'bad value: type error, expected str but found int'}},
    #             'aliases': 'missing required key'})

    # Fail!
    result = user_schema({
        'name': 'Bob Smith',
        'email': 'bob@example.com',
        'active': True,
        'settings': {
            'theme': False,
            'extra_setting1': 'val1',
            'extra_setting2': 'val2'
        },
        'phone': '123-456-789',
        'addresses': [
            {'street_addr1': '123 Lane',
             'city': 'City',
             'state': 'ST',
             'country': 'US',
             'zip_code': '11000'}
        ]
    })

    print(result)
    # SchemaResult(
    #     data={'name': 'Bob Smith',
    #           'email': 'bob@example.com',
    #           'active': True,
    #           'settings': {'extra_setting1': 'val1',
    #                        'extra_setting2': 'val2',
    #                        'language': 'en'},
    #           'addresses': [{'street_addr1': '123 Lane',
    #                          'city': 'City',
    #                          'state': 'ST',
    #                          'country': 'US',
    #                          'zip_code': '11000',
    #                          'street_addr2': None}]},
    #     errors={'settings': {'theme': 'bad value: type error, expected str but found bool'},
    #             'phone': "bad value: <lambda>('123456789') should evaluate to True",
    #             'aliases': 'missing required key'})


Or can raise an exception on validation failure instead of returning results:


.. code-block:: python

    # Fail strictly!
    try:
        user_schema({
            'name': 'Bob Smith',
            'email': 'bob@example.com',
            'active': True,
            'settings': {
                'theme': False,
                'extra_setting1': 'val1',
                'extra_setting2': 'val2'
            },
            'phone': '123-456-789',
            'addresses': [
                {'street_addr1': '123 Lane',
                 'city': 'City',
                 'state': 'ST',
                 'country': 'US',
                 'zip_code': '11000'}
            ]
        }, strict=True)
    except SchemaError as exc:
        print(exc)
        # Schema validation failed: \ 
        # {'settings': {'theme': 'bad value: type error, expected str but found bool'}, \ 
        # 'phone': "bad value: <lambda>('123456789') should evaluate to True", \
        # 'aliases': 'missing required key'}


Access the parsed data after successful validation:

.. code-block:: python

    # Pass!
    result = user_schema({
        'name': 'Bob Smith',
        'email': 'bob@example.com',
        'active': True,
        'settings': {
            'theme': 'dark',
            'extra_setting1': 'val1',
            'extra_setting2': 'val2'
        },
        'phone': '123-456-7890',
        'aliases': [],
        'addresses': [
            {'street_addr1': '123 Lane',
             'city': 'City',
             'state': 'ST',
             'country': 'US',
             'zip_code': '11000'}
        ]
    })

    print(result)
    # SchemaResult(
    #     data={'name': 'Bob Smith',
    #           'email': 'bob@example.com',
    #           'active': True,
    #           'settings': {'theme': 'dark',
    #                        'extra_setting1': 'val1',
    #                        'extra_setting2': 'val2',
    #                        'language': 'en'},
    #           'phone': '1234567890',
    #           'aliases': [],
    #           'addresses': [{'street_addr1': '123 Lane',
    #                          'city': 'City',
    #                          'state': 'ST',
    #                          'country': 'US',
    #                          'zip_code': '11000',
    #                          'street_addr2': None}]},
    #     errors={})


For more details, please see the full documentation at https://schemable.readthedocs.io.


.. |version| image:: https://img.shields.io/pypi/v/schemable.svg?style=flat-square
    :target: https://pypi.python.org/pypi/schemable/

.. |travis| image:: https://img.shields.io/travis/dgilland/schemable/master.svg?style=flat-square
    :target: https://travis-ci.org/dgilland/schemable

.. |coveralls| image:: https://img.shields.io/coveralls/dgilland/schemable/master.svg?style=flat-square
    :target: https://coveralls.io/r/dgilland/schemable

.. |license| image:: https://img.shields.io/pypi/l/schemable.svg?style=flat-square
    :target: https://pypi.python.org/pypi/schemable/

Changelog
=========


v0.4.1 (2018-08-14)
-------------------

- Fix previous fix for case where schema results could have ``data`` or ``errors`` with schema classes as keys.
- Ensure that ``Select('key', <iteratee>)`` doesn't call ``<iteratee>`` if ``'key'`` was not found in the source data.


v0.4.0 (2018-08-14)
-------------------

- Fix case where schema object with an ``Optional(key)`` would result in ``SchemaResult.errors[Optional(key)]``. Ensure that ``SchemaResult.errors[key]`` is set instead.
- Ignore ``KeyError`` when using ``Schema({'key': Select('other_key')})`` when ``'other_key'`` isn't present in the source object. Return a missing key error instead.


v0.3.1 (2018-07-31)
-------------------

- If a validate callable raises an exception, use its string representation as the schema error message. Previously, a custom error message stating that the callable should evaluate to true was used when validator returned falsey and when it raised an exception. That message is now only returned when the validator doesn't raise but returns falsey.


v0.3.0 (2018-07-27)
-------------------

- Add schema helpers:

  - ``Select``
  - ``Use``

- Include execption class name in error message returned by ``As``.
- Always return a ``dict`` when parsing from dictionary schemas instead of trying to use the source data's type as an initializer. (**breaking change**)


v0.2.0 (2018-07-25)
-------------------

- Rename ``Collection`` to ``List``. (**breaking change**)
- Rename ``Object`` to ``Dict``. (**breaking change**)
- Allow ``collections.abc.Mapping`` objects to be valid ``Dict`` objects.
- Modify ``Type`` validation so that objects are only compared with ``isinstance``.
- Improve docs.


v0.1.0 (2018-07-24)
-------------------

- First release.

License
=======

The MIT License (MIT)

Copyright (c) 2018, Derrick Gilland

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


