Metadata-Version: 2.1
Name: schemable
Version: 0.5.0
Summary: A schema loading and validation library
Home-page: https://github.com/dgilland/schemable
Author: Derrick Gilland
Author-email: dgilland@gmail.com
License: MIT License
Description: schemable
        *********
        
        |version| |travis| |coveralls| |license|
        
        
        Schemable is a schema parsing and validation library that let's you define schemas simply using dictionaries, lists, types, and callables.
        
        
        Links
        =====
        
        - Project: https://github.com/dgilland/schemable
        - Documentation: https://schemable.readthedocs.io
        - PyPI: https://pypi.python.org/pypi/schemable/
        - TravisCI: https://travis-ci.org/dgilland/schemable
        
        
        Features
        ========
        
        - Simple schema definitions using ``dict``, ``list``, and ``type`` objects
        - Complex schema definitions using ``Any``, ``All``, ``As``, and predicates
        - Detailed validation error messages
        - Partial data loading on validation failure
        - Strict and non-strict parsing modes
        - Python 3.4+
        
        
        Quickstart
        ==========
        
        Install using pip:
        
        
        ::
        
            pip install schemable
        
        
        Define a schema using ``dict`` and ``list`` objects:
        
        .. code-block:: python
        
            from schemable import Schema, All, Any, As, Optional, SchemaError
        
            user_schema = Schema({
                'name': str,
                'email': All(str, lambda email: len(email) > 3 and '@' in email),
                'active': bool,
                'settings': {
                    Optional('theme'): str,
                    Optional('language', default='en'): str,
                    Optional('volume'): int,
                    str: str
                },
                'aliases': [str],
                'phone': All(str,
                             As(lambda phone: ''.join(filter(str.isdigit, phone))),
                             lambda phone: 10 <= len(phone) <= 15),
                'addresses': [{
                    'street_addr1': str,
                    Optional('street_addr2', default=None): Any(str, None),
                    'city': str,
                    'state': str,
                    'country': str,
                    'zip_code': str
                }]
            })
        
        
        Then validate and load by passing data to ``user_schema()``:
        
        
        .. code-block:: python
        
            # Fail!
            result = user_schema({
                'name': 'Bob Smith',
                'email': 'bob.example.com',
                'active': 1,
                'settings': {
                    'theme': False,
                    'extra_setting1': 'val1',
                    'extra_setting2': True
                },
                'phone': 1234567890,
                'addresses': [
                    {'street_addr1': '123 Lane',
                     'city': 'City',
                     'state': 'ST',
                     'country': 'US',
                     'zip_code': 11000}
                ]
            })
        
            print(result)
            # SchemaResult(
            #     data={'name': 'Bob Smith',
            #           'settings': {'extra_setting1': 'val1',
            #                        'language': 'en'}
            #           'addresses': [{'street_addr1': '123 Lane',
            #                          'city': 'City',
            #                          'state': 'ST',
            #                          'country': 'US',
            #                          'street_addr2': None}]},
            #     errors={'email': "bad value: <lambda>('bob.example.com') should evaluate to True",
            #             'active': 'bad value: type error, expected bool but found int',
            #             'settings': {'theme': 'bad value: type error, expected str but found bool',
            #                          'extra_setting2': 'bad value: type error, expected str but found bool'},
            #             'phone': 'bad value: type error, expected str but found int',
            #             'addresses': {0: {'zip_code': 'bad value: type error, expected str but found int'}},
            #             'aliases': 'missing required key'})
        
            # Fail!
            result = user_schema({
                'name': 'Bob Smith',
                'email': 'bob@example.com',
                'active': True,
                'settings': {
                    'theme': False,
                    'extra_setting1': 'val1',
                    'extra_setting2': 'val2'
                },
                'phone': '123-456-789',
                'addresses': [
                    {'street_addr1': '123 Lane',
                     'city': 'City',
                     'state': 'ST',
                     'country': 'US',
                     'zip_code': '11000'}
                ]
            })
        
            print(result)
            # SchemaResult(
            #     data={'name': 'Bob Smith',
            #           'email': 'bob@example.com',
            #           'active': True,
            #           'settings': {'extra_setting1': 'val1',
            #                        'extra_setting2': 'val2',
            #                        'language': 'en'},
            #           'addresses': [{'street_addr1': '123 Lane',
            #                          'city': 'City',
            #                          'state': 'ST',
            #                          'country': 'US',
            #                          'zip_code': '11000',
            #                          'street_addr2': None}]},
            #     errors={'settings': {'theme': 'bad value: type error, expected str but found bool'},
            #             'phone': "bad value: <lambda>('123456789') should evaluate to True",
            #             'aliases': 'missing required key'})
        
        
        Or can raise an exception on validation failure instead of returning results:
        
        
        .. code-block:: python
        
            # Fail strictly!
            try:
                user_schema({
                    'name': 'Bob Smith',
                    'email': 'bob@example.com',
                    'active': True,
                    'settings': {
                        'theme': False,
                        'extra_setting1': 'val1',
                        'extra_setting2': 'val2'
                    },
                    'phone': '123-456-789',
                    'addresses': [
                        {'street_addr1': '123 Lane',
                         'city': 'City',
                         'state': 'ST',
                         'country': 'US',
                         'zip_code': '11000'}
                    ]
                }, strict=True)
            except SchemaError as exc:
                print(exc)
                # Schema validation failed: \ 
                # {'settings': {'theme': 'bad value: type error, expected str but found bool'}, \ 
                # 'phone': "bad value: <lambda>('123456789') should evaluate to True", \
                # 'aliases': 'missing required key'}
        
        
        Access the parsed data after successful validation:
        
        .. code-block:: python
        
            # Pass!
            result = user_schema({
                'name': 'Bob Smith',
                'email': 'bob@example.com',
                'active': True,
                'settings': {
                    'theme': 'dark',
                    'extra_setting1': 'val1',
                    'extra_setting2': 'val2'
                },
                'phone': '123-456-7890',
                'aliases': [],
                'addresses': [
                    {'street_addr1': '123 Lane',
                     'city': 'City',
                     'state': 'ST',
                     'country': 'US',
                     'zip_code': '11000'}
                ]
            })
        
            print(result)
            # SchemaResult(
            #     data={'name': 'Bob Smith',
            #           'email': 'bob@example.com',
            #           'active': True,
            #           'settings': {'theme': 'dark',
            #                        'extra_setting1': 'val1',
            #                        'extra_setting2': 'val2',
            #                        'language': 'en'},
            #           'phone': '1234567890',
            #           'aliases': [],
            #           'addresses': [{'street_addr1': '123 Lane',
            #                          'city': 'City',
            #                          'state': 'ST',
            #                          'country': 'US',
            #                          'zip_code': '11000',
            #                          'street_addr2': None}]},
            #     errors={})
        
        
        For more details, please see the full documentation at https://schemable.readthedocs.io.
        
        
        .. |version| image:: https://img.shields.io/pypi/v/schemable.svg?style=flat-square
            :target: https://pypi.python.org/pypi/schemable/
        
        .. |travis| image:: https://img.shields.io/travis/dgilland/schemable/master.svg?style=flat-square
            :target: https://travis-ci.org/dgilland/schemable
        
        .. |coveralls| image:: https://img.shields.io/coveralls/dgilland/schemable/master.svg?style=flat-square
            :target: https://coveralls.io/r/dgilland/schemable
        
        .. |license| image:: https://img.shields.io/pypi/l/schemable.svg?style=flat-square
            :target: https://pypi.python.org/pypi/schemable/
        
        Changelog
        =========
        
        
        v0.5.0 (2018-08-17)
        -------------------
        
        - Don't load partial data from a nested schema if it was created with ``strict=True`` (e.g. ``Schema({'key': Schema({...}, strict=True)})``).
        
        
        v0.4.1 (2018-08-14)
        -------------------
        
        - Fix previous fix for case where schema results could have ``data`` or ``errors`` with schema classes as keys.
        - Ensure that ``Select('key', <iteratee>)`` doesn't call ``<iteratee>`` if ``'key'`` was not found in the source data.
        
        
        v0.4.0 (2018-08-14)
        -------------------
        
        - Fix case where schema object with an ``Optional(key)`` would result in ``SchemaResult.errors[Optional(key)]``. Ensure that ``SchemaResult.errors[key]`` is set instead.
        - Ignore ``KeyError`` when using ``Schema({'key': Select('other_key')})`` when ``'other_key'`` isn't present in the source object. Return a missing key error instead.
        
        
        v0.3.1 (2018-07-31)
        -------------------
        
        - If a validate callable raises an exception, use its string representation as the schema error message. Previously, a custom error message stating that the callable should evaluate to true was used when validator returned falsey and when it raised an exception. That message is now only returned when the validator doesn't raise but returns falsey.
        
        
        v0.3.0 (2018-07-27)
        -------------------
        
        - Add schema helpers:
        
          - ``Select``
          - ``Use``
        
        - Include execption class name in error message returned by ``As``.
        - Always return a ``dict`` when parsing from dictionary schemas instead of trying to use the source data's type as an initializer. (**breaking change**)
        
        
        v0.2.0 (2018-07-25)
        -------------------
        
        - Rename ``Collection`` to ``List``. (**breaking change**)
        - Rename ``Object`` to ``Dict``. (**breaking change**)
        - Allow ``collections.abc.Mapping`` objects to be valid ``Dict`` objects.
        - Modify ``Type`` validation so that objects are only compared with ``isinstance``.
        - Improve docs.
        
        
        v0.1.0 (2018-07-24)
        -------------------
        
        - First release.
        
        License
        =======
        
        The MIT License (MIT)
        
        Copyright (c) 2018, Derrick Gilland
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
        
Keywords: schemable
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Provides-Extra: dev
